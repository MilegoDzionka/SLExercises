<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Exercises with solutions" />

<meta name="date" content="2025-06-29" />

<title>Resampling Methods</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 

a.sourceLine {
pointer-events: auto;
}
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">@font-face{font-family:"Open Sans";font-style:normal;font-weight:400;src:local("Open Sans"),local("OpenSans"),url(data:font/woff;base64,d09GRgABAAAAAE8YABIAAAAAhWwAAQABAAAAAAAAAAAAAAAAAAAAAAAAAABHREVGAAABlAAAABYAAAAWABAA3UdQT1MAAAGsAAAADAAAAAwAFQAKR1NVQgAAAbgAAABZAAAAdN3O3ptPUy8yAAACFAAAAF8AAABgoT6eyWNtYXAAAAJ0AAAAmAAAAMyvDbOdY3Z0IAAAAwwAAABZAAAAog9NGKRmcGdtAAADaAAABJsAAAe0fmG2EWdhc3AAAAgEAAAAEAAAABAAFQAjZ2x5ZgAACBQAADWFAABReBn1yj5oZWFkAAA9nAAAADYAAAA293bipmhoZWEAAD3UAAAAHwAAACQNzAapaG10eAAAPfQAAAIIAAADbLTLWYhrZXJuAAA//AAAChcAAB6Qo+uk42xvY2EAAEoUAAABuQAAAbz3ewp/bWF4cAAAS9AAAAAgAAAAIAJ2AgpuYW1lAABL8AAAAKwAAAEyFNwvSnBvc3QAAEycAAABhgAAAiiYDmoRcHJlcAAATiQAAADyAAABCUO3lqQAAQAAAAwAAAAAAAAAAgABAAAA3AABAAAAAQAAAAoACgAKAAB4AR3HNcJBAQDA8d+rLzDatEXOrqDd4S2ayUX1beTyDwEyyrqCbXrY+xPD8ylAsF0tUn/4nlj89Z9A7+tETl5RXdNNZGDm+vXYXWjgLDRzEhoLBAYv0/0NHAAAAHgBY2Bm2cY4gYGVgYN1FqsxAwOjPIRmvsiQxviRg4mJm42NmZWFiYnlAQPTewcGhWgGBgYNBiAwdAx2ZgAK/P/LJv9PhKGFo5cpQoGBcT5IjsWDdRuQUmBgBgD40BA5AHgBY2BgYGRgBmIGBh4GFoYDQFqHQYGBBcjzYPBkqGM4zXCe4T+jIWMw0zGmW0x3FEQUpBTkFJQU1BSsFFwUShTWKAn9/w/UpQBU7cWwgOEMwwWg6iCoamEFCQUZsGpLhOr/jxn6/z/6f5CB9//e/z3/c/7++vv877MHGx6sfbDmwcoHyx5MedD9IOGByr39QHeRAABARzfieAFjE2EQZ/Bj3QYkS1m3sZ5lQAEsHgwiDBMZGP6/AfEQ5D8REAnUJfxnyv+3/1r/v/q3Eigi8W8PA1mAA0J1MzQy3GWYwdDP0Mcwk6GDoZGRn6ELAE09H/8AAAB4AXVUR3fbxhPfhRqr/6Cr3h8pi4wpN9K9V4QEYCrq7b2F0gC1R+XkS3rjKWXlfJeBfaF88jH1M6TfoqNzdWaXxZ0NM7/ftJ2ZpXfzzeVILi0uzM/NzkxPTU68Md64GQZ+vfa6d+P6tatXLl+6eOH8uVMnTxyvVg4fGisfhNfcV0f3luz/7Srmc9nMyPDQ4IDFWUUgjwMcKItSmEAASaNaEcFo069WAghjFIlAegyOQaNhIEhQxALHEqIeg2P0yHLjKUuvY+n1LbktrrKrOgUI/MUH0ebLc5Lk73yIBO4YeUrL5GGUIimuSx6mKl2tCDD8oKmCmGrkaT5Xh/p6rlphaS5PYp4kPAy3Un74OjeCdTi4nFosU6Qg+qRBsoazczLwHdeNqpVx3AW+oVjdhMThOo6YkGJTl862RFq5r263bbYSHyuswVrylsSBhHzVQKDU11g6hkfAxyOf/DVKJ1/HCvgBHtNRJ+b7eSYepeQ4VLZBqAeMjgM7/zyJJF1kuGw/YFpEq458Xrr65YTUa6VCEKGKVdJ+2FoBYYNKCwV1K6B2s1mJnPB7Ww6GtyO04ya/HHWPHs5P4J65NyVa5VA0E0LocwPci45b6tvMvohm1BYc1h12Xd2GrbbHVkjB1pzs6IKtOHeYd+JYhFasmfs9Zt+SZlo9pu8eg0utWZAKB8vjaxBQx7cSbK3Qdr2nBwM27vrXcUHtLolLJyJjK3CAbDcFDo3hsPZ63IH2RrsoWyskdB47jiKitFtcAgqj4wQQxN3PB81RCiCo0Y1jnUVYlOj5JHhJd2JBevIEeSQxDWzTN8PEE3AL90KtP11dVrC5II1L1w331pHFq10vPBGYeyUCFRvB7PAEzMltdubhb+lZ4dw9w86yyNfG++u0ZWOBkmsb+GrsrKGIN4R0XPQimnAEcj3CI6ZDR35zzHJEZlcW5cQCTMwty4umkB5B4ajHwVNhQDqdMLSAmClnhLScgYgMbQJESALUrtIvjpQz9LVxuIPSiYgQkjusZ01l4BERrPtdO9KfDErKQLne6EUbJlXHqTccNzL163tuES26ickjo5va6FIkCyIyaFEYA+lejuqlFxLWIYKmQG9W0tlMe0yXu80wPe/OavEJrd8srSFziSal30wMj5H2mH7T6H218RQ93qOFysDEgtLBoRuQUeXjyPQKexdLjoa4vtAQJiBsEXYutEo9T1/m5mUdBMbXFCzIq8Z6Yl5+7nyic+1mE3xisVatpBarpcC/mUs9/s3Csty2GRPfLMo7FrfqcS1KDxIntwVjnkEtjRJoFKEVHWmelIyxd7Y9xlqGHTSA0VfbnBks08M4W21bHczuJBrTiYixiBnsMF7PepCwTAdrGcy8UqZb5uWGvIyX9QpW0XJSrqE7hNzjjGU5u1vgRe6k5DVv4DZvpVnP6Vi0yMKLOhUvPUq9tCzvFhi5mV9KVNMvWpfRJg1bggjEml6Uz6KmiiN92dh+Gg19OHK4TmOC61TIcAFzsF7DPNQ0fkPjNzr4sMZHaEX5fk7uLZr9LHK9AW9KF2wU///BUfaOnlREfyrK/rv6Hyn3ISkAAAEAAwAIAAoADQAH//8AD3gBhXwHfFRV1vg5974yvZdMQspkSIYkQkgmhdAyIIQQWsSADCLSpajUiMgiAkuJNGmhKyJGDCyybCiyiGBHRGQtyLIuf2UX19UPy7oWyFz+972ZBxOE72N+L2+Yd+be0+5p99wBAscBBIN4ACjI4D4oUJEIVAbIL8wPYX4oP1TQ3um3+0v5dZz2bj44nsyKLhYPXKkaL1wCAhuuXcQ69dsWyAu7qF5PBMFqQzQRkzQgYvIQCuXleXYHlCXl2x1YZg+F7HxMDNAQLQoVetwuKZCZjRUTQqc/f7RjebisqAeuEQJXmpZUdA/3KgcgsJA2kL1xDNPDZqCyQAWdXiIy5YOHThUq4/KB1XFpgPr5heVtJuSQvJzxOeKB6HfEplzKWCEA4Sc+Vgqkw8bwIF16K7fg0ttNJr3DajEKBqfT5UlNkwXJKyD4hCRRlFySwU+TvTTJkJTh1wkms6l/pBWa08Fmt/WP+Nz2AWYcYEez3WwXvU5qECE/VB5ylJXl5993Hyc3zw6hkHaPoerldxVjh7eMX/F3hYWxu0KF382pcKpXsV+9QlS93Mj/Sz/ujinsVE1dDTszcEk1u4LpPdjXmDdw6UAsqFlUg7rmf2J+d3aGLmC757GBuEe55mHNXGxifZVrLtuNNUBhwbU6wSQ5IAOyoS2MCxcH7VmpXkHIdZlFP4BPtOvFdvlZZsncL0Kl1pZcS99Iam5eK1erfhFvrkviL9HDKc5X6OV/ChUq7aGEvw5U6QuFVCbEhOSSZHegODM7WOzxhOzZ2cVFJaXFIbfHK2cH7WlELuK3EnR5vHZJEkzvHZw35S933n0ucur5ky/MO7SraN2mrVuqGiNPnIt+NnTy6HF4fMkfvf+6EEjfkpWPh7rtXrJgp+NAk9hzQScj6194/+yxlZE72Ow0KvcdloMLbPcBiDD+2jdSW/Ek6MENfk55AfQMtwabaPC0aZWZ2a6Nob1NKgxRc3qemb/aF0jtk3xZPtkpc4Xjr3KVXE7WDfpi+sfVJ1RotwUyJVFVbE4ZV3JUPi0pLsq++XMM4A9Vd+/YcXcVvrtx7bLN61av2oINVTU11dU1NVV4cuPaFRvXrV7xDGPNH6+heQJpbMQaHLiz8R9fXb5w8dLl5vO7XnzhD7uef37Xxa8u//3ipa9pxpUqrt5AYeq1b8QPxVNg5BQWw13h9k4PpEqB3Lx2eW0DlmxfqkdfUhoy9Y6EnNZgW0t7MZ/6smlubka+I0NfFckQoDwPkjih+d4yrpTleTdRqoinJE6Ts7AULcTt8mRxQbYjMeLcXMpYwucgMgaCkrrMn668Z97YBwZHJm/+/hnWZ/KwOzazl5c2DerS+o2Xth9eshXXd7jTu7NHHeb98+VHfqw/+z/Cmp5zhvSZe3e/kSOubt2EO3tExnWrrbsy/51x94+aWFa/84V1k/bfx2Z1fWE0+2It+2zfxGEfAaBiMbBctRiug0CpIBLFUpyK2R+OumYgYrZB+cZAdoT4+TfM0CpsksEggGCxGoNUsV4J5sVpc5SGJE6pwxvIJgM3r97+1Kq1S7et2UQKUI/v7znOCn/8jpW80ohvKaN24aOatFEFAx8XLFYDFYItR0UbkQMljuIiEgx5HMS0efW2pWtXPbVdGZb9yjruPIInv/sR3z/+EisAhMFkrmCRXGCB9uEUKgoomw16o95qEwxoJiaT2cDtl84CUP5G4XWJOTBmWLK8olOmNOjMKhUpWZWHK5LZgl9279229we2OBUX50kuVjv5QDo7PBwnsvrhWJF+YDIuVagZDxeFHOF1MEKbsBMEQS+KJjOVdXJ1BKw61EH+feqSTzTz3I7ZA3Zuv+whshy3sDFL2TjctJR6n2SDsfFJ3A0I5ewXfAgugw7s+0XQG0SAfFVWHOEsr6TyphSHW5NHFc9J6Wa+7B3Dfp42HguHAUINniPlZCpQ/l0CogDIrW/8u85iv7sGv8ZzGzYAxjwV/MCxTwobJQCTWU8HRPQeruaaXpRqestVdUOXso7dupeF7px4Z8+ed3arKFc44AIg51W9ch4kIIiUEocmSk4sBpCcj15oUDRJXYYExl37RmirrkIv55rLASYJJF+S3t0nopeptU+E+mLrLK+lPgQyid3mCBU6UP1rVz8R2n770zc/Xf7x8s/Nn9fvaFi3rmFHPfmMLWRP4lycho/jNPY4W82Os88wiJ34K4tdAIQjAOQkx8YArcM2PaAOjSZBL8uolzAJFFvGDXd8ej67P2AvKpUkOYghcnK7zl300RBcsExwzJ/hbrd7GuYBwhgAIYtbTx/3+d4klJ3gtKCQnGIz9InYZEzqG8EkjSzNavCB/cXYlcQshhyMsZrI6PYLWc3lOG/vlA4rHr/3uTFD3r38/r+3fMKOke9W4oJ9G566u7au84CpOz/ct5R99wF7W6dIYjjnawrHIAh3hlungFOWgXoyzVKbHOr1eD19Il6vISsrrU8kSzbY+0QMGpdjgYh60zDTHJKHoyP4404pw27zB4o1o62gq+BLL299am8j+zv774zj995/dgTOZsOfWr3rnTWPj2h8qGbo1/M//kYYvmxfms7TtPrM54E7ns4vwBw0rFy/aNJjRRVTet31OgCBPABhongUDOCAzuE0h6gnxChToCJ1ulB0iH0jeqvscFBZotflk+hMQ5oJDqhrC/l//FxmAUlGYeK5Z6Jl5MDec2yJQdc+l5ViNduL1avoZ805eGll04jy6COKheT8S+U6kQwdw+lW6nPpXF4qtEoBziwAye3mMnRLkqlPRLqZdQlsKxTcLghkqhzjrLL5M+WgUwldSkjbL1HPLrCf51d8MHbv66zu/mcGl5Kz0YNZ0+mcf759kbEB29qGGrZiYWop2b2R9fYqnKnlWOVzqXqgNfQIB5LtRr8fQLLT7CyT0ZLaL2K0WFzU5e0TcfmojkckcgvcyhJ4pNlr8Bd63VyEhIbiGhfIBFGTq8R9lqcWB2Dl1G79Rn/9i8n08OU3L/760UX2E369YuvqVUPrI9VryFR8CXc5V/rYefbW7svv/YNdxUHv/OnFVQ1V8yse2Dde0UcAIY/zU4L0sA1FEQg3jJT0jVAJFBlqbOOrALk1dCOmkuHNF+mpaKOYunHhldNAlZhEyFGpz4R20C+c47Vmu+6gqXo9lewuq5TfXrLnZORk9Ink5JjAlNwvYvJBoF8E5N8qd9nN3jrmj7mOx8OPLDXqolpgwv0zZkpuzaeTynf+vWjNvnr22b+bsfDJR7+e+cL6dQ1bXlu3CDvOWfHIMytnrhJPHt7x4L7eg/48+8C5U0euLuu/f8ozr1xteHTRssdGru8V3kwfeHTMsN937/zksLEzFdlO5NQpNsMLWdAtnJlizzQYAAQu26AljUvWZbEQlyuJi1Ymcr8Iaal2jjKNg5qJ9Ctqx02jMyDFKHJw8TpUIvjHKhXZQlZ0/Iwe1eO++6/RVHpg2mv/uPbBuguPMtfKLU+tuXfjkIFraEVzg2tlMuZg6O57/vXBP1C3kZ3H9od2PPV81RMVE/aNAy3HEcaokRS34Ta+LAA8XotzQMRiizkRDVfN87X0JXae6NzkVR6Znehb6J8XL+Y3IKovXMjn0oEDMrkmmc2iXu9yGm0DIkab6hgTZklwj/T6FDccpXsmn6Rjlxv+knyrTFMR8+U/cF9+DiRwh/UCiChwdeXD58cDhSwsRjeikNNcTo83/0AtP2DDKLywji1nhxSezMTjgo9eVHOy3LBbJgIQ0OsEsToiIFRHrIjI4wHOlfxEz6a4ZOTXTLq9eTjdTofW1bEH6up+g5GIBDhGEr2BkRNVlMZTa/P3HKVyrMMKrF3H/KPYUAWjlGsXaRnXrxTIhrJwqp/bMtnphFYWIdgGoLWtddqASGuPzdA7YhNaqFZLvVJSEa48LZwUd4YSN4mJ+aq/ctSSXgtmD6gf2emV91/9KNj38bHd9l3PX0tq19dMnzFw3OSsgsWjj+zqPXn0w4On3e9nZ+NJLYFZ1yqkQ2ITFEM5zzwyA+1KLJ1kVwpAjsvSTgx3S+rQQeiisxv5Ky+9kGbnqUmllmSFEhOP6/G4ug6C2nJQUPdSt0td36R1IFMgbsUalrqlQAbw4KK1v1BwIH/udKqm8NCQbeMHP2LUtVk3rv7Fb4712N3Tt/DeaWvZt3+8wA7swe6Y/5cvjv3I1rHJn+AyhLM44ODVn14/7bBUDpq/hpxb8c388XfdM+rU3veu+Tws17Pv7O79aFvzMnvxc3aaHRq8sAZX4jgUsP7CfvYntoNhGYquJiAAAKJNPAIyWLjk0ojFqENR0SwqyILNaiG9I0bRYhFECoKD518xh6iplZYz+5W8H0OIlBsz/tURB6IHmnaT7itJORvb6A94cnbjGZYvHrnSg0zENwfPGTGddQIKJwCEo9xyW8ALGdA7nO0UUg1Wn89iEGQLjwd01iRrUlXEarWAxVcVsTjAWxUBevt4QnM9/gxBMbluwe4SAjxpj/mcgN0ef3cCt2IAhVVLsR/7+TIjjZjU9PTeY1ew4I9/Ovhn8cCeI/Nf9BnK2Pk3/kZ7TF00+6HoquhndauXPAGAMIdb09Oqr8gOu6jFpbdQb5IDekccglHi/HK2DL+4emRymUNIE3+Ro3WokKfbtNP37Cs0/7rxjQ0X2Cvs2Rex/NNLuysbxBB7lX3FPmdvl64rwyU44QusOVSzuj8AUTgmDuEc04FdsYcWQQ8COJyiuSoiUsFSFREct4ppwc9rSBlA+ZuAPZTBx2Az2Uo2CY/hIHysic/1z59PI/dU5CtWz+aJB9gi9gKmYebVKZgHgMq89Bc+r1GJWSSDAQXQoWAyS/reEUlCQsTeEUKRr3B03DZmUZBwxy/6S/MZmh+dTYZHt5OF4oH1LKc+eilhJj0UhpMlAKQ6pAbjTRPxSW45Q0CbAac3asPzwaNfrY9LTuyi2ilOhUvnI8SSohNapUJK7wiAaDLZe0dMgujtHRGdt4+8/HaphRyV9+rq5lT1xe9nfPc0a2IrDuKQL//9bve3DrL/so/Qj0kbVrGXCYuWZWXjUhzzD7xn/+D6GvYau8Q+Ze8H8LUY7WK6yuVQ2KdHBJ0giCCaTTraO6LTiQaJoshJV81RgnG/Qbydi5f/DYnpjc2ssZGSRrI3Ws1z7dXkYQC8NoLNxfFqVpwaNht1OotVT4GzFDJj9GrpGI15+JJiPpxLMg0v6dVv9AONx9jclFWuR6fyFGvI0TNxvRC+UjHmnkjBViRGg4Ix0Yn6RGzLWkgJZRVRDKHw1TvRrzc2NpL1J6JN5M0l0dc5snnk4+jCBF0QIT1soQCCJCMFzgtw3EBXxTekkO0+0aio0pV/bIp9V+KIgpPrUZJOFCUev/JSmsuNBjuVjDK1gKQgp2DnLbuZlRjwuJUAn2MY4nce4COtZjadZSsCntbhh6zRomMm0bbpo+bh4oGrVQLPOume7Uev/BCXo1IDsUG7sFsvcaytVpDB7jBS2aqjKCdypaUI4xPzabNJKZdj+WvNn+tsW4/RVB2xkGeEk582NR/nE3ZMwaxy2guAqFp99FZ5bu+IXqDW3hHqvLVNiOltBiTmueJRtpW9oZgjHIE9sBOOujo9+v1/fvn5h/9Eeb77LHuYa+94HIt1bArbxs6yU1iIuRjEAnYqZp+E8erqdUBRONnA+c75DE6XQaiKGAySLDuqIjKVEtavhpXmSgW/mlplYChutYXx7Ay7tLsRZ5PWUePGL949euKoYPr7t1HOh2jK6mdXrVC5wHaoXLBCCp+Zp8MeAIEa+OqmZtns6x0xC7KTL2yZM+MtlRs3J6I2pViG8q258sX7OOxndrH0tpz5ki3rzuqxivyf/DnN+WMCN1SGs8yIxKS3y0aDQdYTwePVm8EMVRGzmVDK5UepkSi6cntnp2Ku8ktw20SOf5bGNm4BcRXyGdhfcfkJ9jQ7/VXTzl2vfEZGRLeJB94/zf4+LjqZjFi9cuWqJwDVHIFw29ha4V6a0wSQ5BSFrGxTGvV4uH30CFSfoEoJiY4mt0CGlozy8D+o5jgx+6jmBbwy4BEI+9d3rHnZ0I/GN+7usnL1ey+xM389WLx/1+INHRbWXfoDLjz+6Z07su+YN73vyIFFvd959sV3qtf2nfFA35F3FQw8AoDgABCGcv7JvJ7iABSRUp1epgK3CYLmFeJ5qGYSi7k3IEsbWYFQyQrE9PWqJzjM14yPj2OHrLDdhgYZZafDrqOCmQ8UpzGUuFzsLkUnVHMYs4uij/2F/cJfFxrfee3ld8QDzf2vsC8wo5nuaa44+Mabh+ghQAAA4XW1/pMcNqJgMuooCJQqiPLlrxWvQhjgF8//SgXTwej3O6M/NmF1x8zWHdVaFh/5uU3bnwXkmg1yXz6aT6km+QwpyW6LRdQn2Q0U9TGTotqUGOKqNclWAjJldKcyenwSZ0h8cyc75y5CT3v2xU42u+nL9p6UYpSa0Nne7yy+1EQ/7PaW6/dbm0N88llHNx18ic5qnrv59RXv0YUK93QAQr1q9QNhhyCJ3ORLiskXFJMvtDT5KhocAz63Yu7rj/PIY0oTXmKdjuAkfHg/60QWROeQZnI4+gq5M9oX4lybrUY5GWGrIBJRpnoDiChTUeOcJmE+qKL+GCJdcNEhlrSb+Q6T8+R887zoCZJPFyv1ZQBBscZ6pWKmQyqDLKBgMIoCNwcUdUrMcuuKmVot8AvlzU6qi9roq82/0LSFwoaNC69OAIQGdoRMVnSRY2mRUFAYoxcJlTDIOdBSfeJRD5nMSvEEu4B+dkS6svyKX6HWC0A+i1c2Kd5c2XRy3h0mgYbo/4spg/KNEDuCzdrMFFACSacHOUgFevPMXj5rMb9CfMoLfOrSA+KF5b9KyigFJCgExOMgQVJYD1TWiQQEwrO+G5rpVFUTC3DfaPxsA1vG9pEg3dQ8jnwV9QJea2Zv0k3XKtUKsJLHIlEqwBgjmU/LQUfRp9mbCwCxTjhHHZIf9OA8AILRID2BkJ+s1ZoxwDW1OMStBHU83G1fm5MZ0+4QzhUdK3f33F8MRKk50lPCUEXzoVc4K1NnTEvz+Rw6yqMpYkzrFSFGI7jd1ooIt4LJFRHRA24o/98LVH4tX7NllapJZ7zS6LZn8QVeLKsVKjrQrxv43GPPvUychyc/VveH0F3HR77xCrNs/mPDWy89tOWB3js3Y1+b1GPe7Jq5dxTuORZ11TZuHC3LD00fOhwI7OVWtVZygRPSeVUt0+D1Wq2mVGqiGX4zmNwOu8HOhccRljzgqoiArYV5DSXF1SDB1sddEk825YBijeRQiVcrvHAqyJ5Pv/3+k0l/7GwKzGzQ6Wa811i/qXFjfb0wlJ1jP/DXxwMGLpdcbNHcsTuWvv7ll29fOPPJXwAQpnMOLxWGxbIaK6VuPU3ySmaOmQ0cHDPPzVmNGM9qlJ1DHgNzu6hmOGTcZXYV9f8d8HTbUOn8QrbvuW11Tz3swiw0oRPvyPQu96Sywe9+2mlNGRBlVqGU88fB+dM97E+VvGCx2CV7ht/htgIgmqhez9mjt1FnRYR6bscerSYTkLTqvTcUDPLPA6osi+JOiG7ST//n2W+/++TCTLMsNCxmTzdu3Ny4evOmNS9gNlr5647tA/rh0V+/mfny+4Gv3r54+i+fxLF0cN44IRk6hdOTDF4jpdzqtkrxGit4uRskyaUyyqIw6paZQyiRZQ632++JsUuivNbh53Kb+x/2JYp/e/+7qFl8eecf/zBk65bfb7WQLstc2AZl1GMH9v3fJxx/p2pttp/+c/eGrS8oUksFoBYpHVxK3cVlMjkJ4UaSuj0GvhQMgKIsVkScspUqq0GtY98IAxWmOZS1p2QNgeJSXkPW3DX3mE+zrxreeANH3lObN6LH8KHopW83l9G3+3TugmsDC9PnPNkLgEKQuYQCzplcKIVu8HC4a56vQ5YpvYtY4ESnSHIzW6Vn+Qzd72xlLbYWV0R0nXpFDJm6XKvOqvPk5pJekVxrm/JekTY2T7teEU9KnHUa+zj/8pXd+rzbxD1uragaVBdAqDC+jaAUkrJv/OXKcGMXmJOnbhQXF/F3QsHJVnf87VhB3sSqoa/te5X9jf3r7FdPzMgtC/ccNOnTtwb3ZPb6ZWdOPLzh7amPD50/4z8/1T4uVE5ICkzt9ewxXYdBbfPqVx54ddvqMauTndXFnYfmBnY+2PS66ypEhs2ZFOn5IO08/ZFvfn4cEPYCCD24nnuUzM5i0nFz7dF7vEkWvcMhVEQcNgOA3q0Y7xjlCatesVT2mALbtRUfM1P06cfm/+GZhgadoWD/jBMnyJuLfn/kk+jrfHXnDOow4N5XP4gWAxDYDoDjxAtAwcr9tZ3PJCDa7Ga5MmImVlQ04/3EwqZSIqAJJVQc3NDQ1CG3TceObXI7CJWYU1Zc0qFDaSkAubaKudSxTZAEd4Q9TqPRrNP5kj22yognrLcC1z6ISzW5xSTOhATTljhb3v2det7Zv/eNGZnLt9g16B6h+aqNHZHv0yaP8TSV89QGJTzetxgMRqNOEkSdYHeYAGw2nY7KRje1xiKGfD5zeUyFyuJsRTUiQi0bdclYkzcER73JeuD5E2zOnB07dKSgy2icydpGlxLpQTZOcjW/XTo9NjcO5nNT4GQCoiASQHfca2tMVBjHYVRo6SRfJQGoCAfcdruDiz+gdwRo66xWHrfb4RPMPm5p0302p1UPDkUPuCLEt534Igi1bHVIVIgEzfAqepHh1bRDypryyOa1DVNmblnVsDhFl79rIuIAXcHhmYdfJicWLNj3cnSLcv/zx9HjQmV99dDDg8e8+heuMZq2cnxdUBBOApeiri69x23S22xcWW02g/V2ytpSV72Jmrp7m4JG6NDUt95RNPXwJ+q8d0XUSWM2dhSfU9EknsU6wSyDnOwzeLgds1GbYvxvmcVylSHFilGFxE4PYRT74fKaf/wOTZcvobX5lZ3PPffii88/10Cy2I/swyeR/AFNmMfeZ1f/8rfzH545p1j5vdyW1apU+6E8nOEzCrKsS3foHJkBwQhWq7siYrXprboUaHXDzMdZ0GLBqpaeO2hPAhMUr62Y+gRHrThpU8Niry7c+PBf/+f7yzvryabGFc8+6xowcMRg1kUqqh9azT5h/1GcNr14+GTWl29fevfUeYVXHNNSlVexqMKW6qHJyT6bL8OfnOK1pqalecxOp8wtv80MFRHz/+Y2VT5yJ1l63Ul6r3vQ0njtQyL9GzaIW15cvXnjnI8uf/fJ57P0SQsajObpM/d9mHXp3YunT59birloRDO2a6z/9T38eEzFCzE9okGOpw1ywy6zXm8wEF4DsZrB4FYtg03rc2nRkaE5IY15ZEfvjt4eRQtfaahz6rrsFoaZNlk/fTbaJFSenDQjlrnS6XyW1twOtIplrqLzeuZaEfHYJKq/rj/5t8pdueG5kbsG25Hfpq50+j/e/+tjA/bXzF82+dmN88r/evSPL3Z6ftEjj7Yds+J13jSzsaHnpjbt7h4Uvrdr2aAH+yzaXLm4R1W3O7p2KO71FCCkX/uG7BQrwKPWJlwu3jPioEKS1+C0OXtFLGGbVeaCkj1xU3kqIVjV5ONWqo52xVGXhtxKNuHyEMcdA5NSJuSy17ZurRiBXdlrw2vN8lyzHQeQZdU9/83mRWePngiAsIOvrjKhElx8fh86ZZPJ4DS4PSaz2aZzWdVV7TFqEbMS/4daVmW0rJcrhBY127EvX9TPNNQl6UP7Z7zztlAZLeMO6GMSvnpozV2Dj54hp7RcjgiVau+HAQ0ms6hHK6jhiJZl+NX0NFTicIYQt7ER+76ptuiMte/tYyP4oI/8o0cx9iPtrx6K5UpSgI/Winsblz4lNc3rsZipYBZ0yQ7ubnTuxCyYK7c2A1U2Z2Rlk8LhUHSq1BmbsoRPKeSfcBbp2qSdPsY+3jNxsk5nLHCcaHqjg0snBF7dzc6QBZ3OvHR/dK5QyUaz6j5l+4tJbXTp7trW9eRvHClACAIIOpXGzLBdFiVAUWlxQZ3RLaD1pnQ4ngmjmhUfYgteQT9m/JktwFVH2Cn27hFSQLxsGO6IfhU9jUdYD0AgfL1LfHw3z/sVMqnHK5jB7OBLO0UHfIJCVam1GRJo46KKOdrSUrLvuwFOnfnuS/tYTsWfl/StKu2xq3cXzuCVn9wf+pn87mrGy5vtC03HtkAsZ6YPCZW3yJl7RUQr6npF0P2/5cz0oeZ/ksHR0+TL6D5y31Q6eN685sPxrixetlPl5/YlJxu9AFbZRbmnpqlpTq09K3F7TdV/bpXcPJZTfEtxCddDvj7d3EK4ZLfHjedrpx794PFH58/49MClCxdM44aRZaRxE+aPjywnw0Zg4ebdS6Xj7NzZoCl4FhAvMxuZrfluorSo0RSABN+tlHzx8nKeJv3cDAiV7Ijaw5Oq4OwWDQ4H8UFqqsXiE2laujso0QScEzYFFXSDxYr7U7DPVNCV5Dj2pcRw4eKhDx+Z/9jjp45OnvHwVFIePIvB49LSPRvZ+yPvJcsjvOq5cRenZNg4zJn2qEvdpyXVQg6tAS/XAzu1JvkcpuoIdVglCaojEuTngS3pjfw38rSkOlOZT8nQVNOmbD9lKoU5HFg8t2TMUz2mRrqPyi95omTcisrHK/sMJSfuLFn/UKvsVinhsvqH/RkZSeoOPFuKdcJwrcuYCALV8343AGpSu4xtNPOWXcZcCQNO1/Xt0PNKk/Gszp3Ly0IVZPfVC2Lfxb3C5ZVhQDjK7fd5dVemazjNozNTahCARxo62irVJxKnwUz4SzDKgg+07k9ljt9sw2apra1KOJCldLR6NAOuqD89OWHNwpPHcdniPisKChY+tHv7My8sX/FdifTO+xlov4LNXXfvoH7vstCH5z462QkQypUYSDzBpV4Zzk5y6s3mZI+dGD1OMS3dlORL6h/R+3xOcNr6RpxJIPa5uRWkRdPQzZ6Nm29lf5Lfinl2ypuduEqQxqONXTatnD0HG9jQblU05erVU2+99f/EEzUL+/1uGTs397MxS+7YtDz/xwtzsfO+U4psZqMkeIVtnHNByAibW0GmBSxtctLd7iwZeNSYn1gJchaVBku9il8r9co82Ja9clCxDnKwNLs0IXQ6VLV4+OLx8+eOq7t/UVXVgmF14+YuGrN42MKqeVtnzHh627QZW8mHj01aNmxh794Lhz059ZEFD/CHvfj7JZN+N2XbM1Onbd8BiscDEJT9Fw8MDrdzWGSj0WYS9URPTS6LW/YmGSwW2So5HBScbqsz3UmsTqvThG7JlATlWg+33RHrzL7lpjuGUOGj1uaovjBEKnH2HjYCJfY6dmGv72BvYGd+ARu7j1wgZ5vZ3Ma57Ec08RslQBKsgaxUVYkkUR726QUqUDlmFjgmiYqtbgjFLYRiI5p/YebmnxVpXPuF1kupUABdeGdcdiE4pdy0Dj5fmkmCgNS13E07lbRqK/n1/mCviN+tt/WK6OGGznh/s4t9I39VVFmLztSUlwuwZdCiRC2l/Kk33lG0dHD/qprTbw5/ZmTxqMV9Z8yYvelw/cCqjf/+6K9P9H9t4KLl7R+cvmJR99W/f6Ggbs3LPQbRnMF1WW0mD5q1NDW4IJjSKdy5prTH+klDl+fctXrZxm5rs9r27dWuY8e8oqHTRvWb0MVZPfnuKWXOMUCwWLTQ8eKH6u5TWpiTanKAI8lnpW495N90QCAhzctKeI/FxVnZpaXZWcU4pzgrq7Q0K6tYnFrUrl1RYUFBYfwOQGEM7xzvEdt5hxKeSwWDXmrNT0936a1esbSDZAKH1ZRuIuCwOYjJYXKk5AWcoRQByhNPBdhblgFRMxHuG90bnN2obu8KDjc3eYHM1py5DiFU2NqhNXTQOXMWz10weE77sRWvffDZq0880vHB5vXv4PB3les1tv2D02z76xP2YNvdezD3pT3s7N497JOXhMCeTTu3t/2dq9X3n575qfMjIXZI/Q7b/u6brOGD0zj0rT+wD/+wB3P2xr8GQKCCushU8W1OdzqUhlt5pRQDokeJazP8rQwGh88D1EYJNTvSOakf3feGku9qVGpqG4xTV8ojfbXWGSt18iYUtdZJXEnDlt0/edPztWvHjM+btnB+HauecmLUlAeov2bk6HHjJkhCcGFoRIcJs1jnI2OaCgRBqd8NhFraSI+CBGbICTupxI21YNTrBbMkWKwmUYegHGS5WbPRiyhjVuw2EAfPVEriM1kjLsUhtexzTK9lO0kQ1/dk29mzvXB9yo23qh9EHfeDXhAhJWwiKKAki0J1RCSQr20nattixUJOXfM71Bv9Hhc+CdeuaV3LRAIbAAjXdUoX16r7wqGgF3iOLui5Zpn1JodXKu1gsnFoi9Pi0DmtjnQHAR63E4fT4bythikCCP22ZKVVoUS+hp0Bqm51Fnr+L2UjHz5YPXLwfRNx36B+l3eeXrwWxYbNVy/8n+pGrtwd7tNtSfXsNFaLo9jTdPZ89ub/pXB47YrkEiRpzW3r+oJ09UfBJLnmAoG5dBi5LJ5U83Z/2GIGp7L7nGwzHPNQhS3J7yWaAKe27LkytvA6c/fPn39g4Oqa+fun195VPX3qwLunC2vmH9i/oGZlTdOCgdOm3l0zdZoiv/GASic8yQYLAMhwBiA6Q93NqCLLub9OUmpcstOLaHGCwAsItnQvZqjyadHEUVx6cz+0JMt+sjy645vIQH91edGont0XbPj9msiaPXiIVI2/NHhk35IePbMLh0yeP6V6/ZPPA4KflKlzBqAsnGkVRaCONIPUOstxn/MhJ+nrRKMzxUmcTl2yP92s88eVhKvIfTe2KDHRmKtlyd/2PpPpA3vsPbRzw4w1sz/8snbmA6Or7+w+pUPP8mXDl2wVvqx+wJu//YmVHWb32L5q0oAeXXrkBYa2LZl5056LnkfvwhP6xD0X5YAIN3pyAOvaT85494494cnCD133dnN3O1oEqNZDegiV4IHicLJoMOhs4HS6dC6+LeC2ulLMRKks6LWkMWHX6XqfaELKyMnTOhsGs13PNCxJNkz+Z/0Qg6GhAeewK698pKaNLwyr2caOScrsU1mzMEJygRWCYYcgIoBopDa7TidSq4jaQa/8RJkG7MortqVTEvILI6Z9PL1rzacn//ov0pY1S3t/raYhx5WrKDBA2ED6Yh0dqvitsEECMJuofkCEQsyAJOqq2jzatUOseZR82L1nz+7xMwlZzIVNAOBQIge7xQhgUfrILXa7jtog/71CzQq3qDNoZYbSkOzBpo31obZtOw24a8BDQx4ubWIXRk7UT9S1Kckrtu+bHgSEvqQKP1d3kPleHwFKDSZuX2mGBGlK3sc5EGO7FpnEzw8MXLlQ8pQsvpNv4K4ld9471NP2/hFAoDt1kaPi26q3zgo7lONnEnBvHfMfbr3iP964r4XTTjgzJSYsWHJ0V/3qF3eu3/B8lN07fsKwYRMeGCZM3nHw8LPP7T+w/TH+b/YjjwCBau4hdsY9BF+ZRr1AgMrEoJdu5R/4fBhELEUxdqM72c5aTGef1+IQVnvjPTGxCb3wfhzek01IufGW24c+AOIZzq8gnCYLACAbHrsGKMNHNDV6EPR/osTBA8ziYuCw7Tjs+ThseQz2CwV2Ou3PYeV9xMZBVchkAMkvnuAQM34FFf4CxEZ9KD5qXmxUIBBiM2mNMBxSoY3Sba1zpQWwlbVVwCXk5EIqmmhqKj93lzEgkm2zG3tH7IEWecP9w+9rGZ4ohslCYnXDUm9MGF2J0ihbnJBfkf59Rs7q4vv9Y9X1ozq9+dbRTwPhSMnYbk2zOnXtXqqkXKHH1tZM7NOvw5ip2e0XjzjcWDEhMjB/yIz70jFvcU/eGRvmVKrdoPJ0bltbq9R1v/YaDgTdn4hNzIa84ltA1MLCGETS7SCOQSAGkdoSIv86xGsg3HKMrOsQE6CUQxiaKGmtgtyAkWIwIMNxKIN5QK4xAIk3MIIVnNA/fAdPM+wIOhPaRNEtuvROycm7kHm7iMHM7wabASUqOtByowkglmHm5an5G8bOiYau9y/SAF7vYVQ2zqR5UUeUXdxLDtMT0SMkNXqR9Lhag0cfURpetbZG/AvZr2jRHOZSOkc5ztkqzrMIAf55rM9N5VmbON8PqhxBs8aRmyFqoTwG4b4dxLFrV2MQyS0hsq5DTACHylWC/hhXgUA+gFip9id54Z5wod3t1glmAKcgCUk+rogS11erXC6/JJ+WL8jcIsuyoNfbqiJ6Kri17tNEXW55EDWhHZV7uVhLarxnM5QhVqpNqbM3bcJ9eBf+bn/07S9xNlt4lIyKtaWSunqyntWxHSQcba5nhhhNYrmqS+3jurSmJdWx7jiVLwUx3sKsmLb5bgdRi4YYhP92EMegKQaR3RIiX4PgeGy65RhZ1yEmwMdxnW4b5z7CQrQJJmEDGMEX1st6ino0mXXgy0+0x2rMHLeOu0ewbTh8BHua7RiLw9m2MThS2DCa/3fbaLyfPTsaR+CIsWwrAOXzv877434CJ6RAQFkZnnRvmsAPExtcAA6rqFMCF0+a32f2945YHTpRoDazQHnjnES1lrm3+Fq4+YgL/ygm0lglwc7fxSoM1BZEj3qKzovZ1zsLv1479tEH9ykddGe2jnx04rGmh6Mjpu/9zy/NwbFk68SdWpPhmOUDNr2FDyl9dMMXV699l61D26bmvgOVZjp2ZRN9qTc7xVdOrI9LlUxpXLoVMfk7Nb7fDFELp2MQKbeDOAZzYhAZLSGyrkNMgA3xlRNMtEfCbHWUTvF5CmKjOFSQeO/frHjvH9+pMOtFUbKDBB6vWeALiC8fs96sl2LdkZoVarkRrHVH8v9lCDcaJGexM+zzQ42NZ9GHnuYrO3mL5LvvUdvFy4zXWq/B6ei/V+5Y9yQAqv0oW6R0aK94ppxcMTUAXpMJUu25YkGhw5Hbrl12RaQd5LrV3S5tj+vm0xpaZCBL2vZIQjWCo6Q2/2lnOTKUqE/1UYJv5ZAOKb36Lxv32p+OTCrfUnn27ofnjujZq094yVz2TcPf/v7+58IPi6dX3OnPyC0L3b917LZdPTcF8w/0mVQxcHZN+cTisqHF1YMuXO0r7Nv3562c52pXkOTnPL8TACXovgLUVWlXOH6L57V56vN2t3t+7FP1eajFc/Gz689fe+UW3xc/vP58whegruiOKsCNGRZehzj+cwyiTQwCqAIhKbtXOVDENWdkOJQLre3tedlIaF+WlJTe3ghi5y4pbYNtKyK+AqGgV6RD66BdECyZQU+xzqKriLgsNtBaO9R97viBxZsNL1corarUot3Jy/+qHSkOv7bLFExMz5TiAMaaVIb/wg7NmPnUc0VVb4+a/3xO8a6Hj/0reqcOO967tWbwurHswpy73lz03Mt7Jg1ZtfPpwzvoK7OWGon8BOY/+yddrEUqp/ie+4eMYP/9+yRWGwjyVpav5k5sXH9/5MVNo2XdQ6Sw4ektO5V1zXc4lW4kzreeMU+JFaqnVDtxVIn1ikl8vyqRVppEbn5e21993vp2z4/9rD7PafGcS1R7PsEQk1d7TaLX/gqAo9URXolZHHYXKGOgqI3xIgApTICovZYRgzDHIa79iUMMSoA4xl6IQTg0iG84RDrHQ4OYwA4CqBbHZ9d89VRlx1zyq6euqsJ5fsnUqhXwYN5jsTttkj7YRp9eETFSj91nsfLIR0+9LqSttY3QmLJw6/3b430QyITiIlAqxdlBMcj/lHpUk+6gRVqnV4kwil39+e/sK5T/9sUYXdkp9n3vr4YN77ll3OW+pzc8v7NpC3vppe0vPUtC7Ev2FzR/cQmlWcInr25+cGHXgtrefZ6cNHMlm8b+taaRbXjh4Aku21jXgbraqmOrzaLyJC1RNqNUrt0Vk/1HquySb/e8drD6PPN2z4+p45Ngi+d8fu35a9/f4vtcJtrzCSkx3Wh3fS2Ph2YhR9gJVO1CD4WTPAaDTSACKjsZTifKZjMqJ/QQ8tX1yhOfG8nPjUN6iccXE96Pp8ejezqVFHXsFCrqot3J8iefZP/q3KW8Y1m4nPwYfwOUY3tEGCUsjvv7PvxEa3orl8vQ6iZn76u47uxt1M+b2Kjnf3P2ZWVxBdGcfXw7QXSpTl4Si1SnX6L2X2yaUjNt+Dw0Xd40o6Z25NzmV4rxTJ9pvAljfYjl95r63Iuxboyetf0XbEBQGjL6zuy7cMOvu8aRRcWffLRjTHRO6DzXjNjutSq5e2KSf0PVDI8mmZuf107VNOfWz4851OeBFs+5ZLXnE/yxtZarrfrYDqw6wr2xGWIjpKsAWu+I2t+VyXex0jOkFJfNZpfsrQMOsKeYPHqqT+NdjB7q5euvRZPnb3oYUWsXUUomXo/W9JUVbx7J4HugOKR748Sz333/yd8fMwk63mSElTs38OYRzF9LmyID2Efsvwpjn83sV86KdcDaFQ1NOXQi58u3ce/ZMxo1nF6Nmgn7Y/TmxejV+puEyuv9TaJArLfsb+Iw6gkU6UvxFLggHe4Ot0uSrE5nKpjtqZKY4bc6eDxpBaOR51hGGj+Vwg8UUAc4b5zk4det2ia1fWVJO2TlvZF9aafq7NnSl1EYN4y9zJ7BYRgeN5RaonxdR8+Rfs09fmXXEH+ecs89LqzDiTgeF3ljSZmwlZ1m55QTGn6hNi32qy1yujAU0iAXCmBQuG26zkI8nqx8t7tVlk4oDOW1Mbbh0RHvSCKixdiunWg32pIyxcyKCIieFj7YoVjVRAeseV9R9a0q5rdyvYktTFkxnyvWs/Nzup6pu8B+ROnrBae6djz2+InL0aAOq4Y/e8+QDVf9G154buPm5xvWCb3mrjKRjN+7vp4xEwtQh3q8Y+a0KbPYz19MYDO5tw1mkLIPz3985rOPP/10x9NP7wBEE68Q7pH8YFF6wGWwWXmN0KJs3CSfKkwsE/Igzx1QzhIE0DR3nLfB89CcmUMWLuFF2u+WPJGTu3C+t3TBoiIAgpP5iG2lhdp+kEMyxSpMejflw753u9KSrHUfcfpp29njxj46a8zY3z3YPRTq3rmsqJu4b9TM2lGjps8c3qFLlw78AkQdn+k78TN1N5wPn+Szg2gC/nKrZc73En4mKLYb3o4vKU6BwvQ0olRTQpJEXXkDB/TOLAxZRpmn39tucP/KjIL21tHmqcL5rLZZnbvMquO3Tl1n1aldEci5Ff/FEyCCePMvngykw+K/eMIh5f8VUtYgffQ49lB7+R0HUNTpQenhP6WBBkscHEs5y+QZ1WF29yx63DMUTVyicNM3RdTpRZly061Rq55Od5RisXIk/bGKDPGARzmLjqmfcouq/e4LkcAKAEQZizSpY1khOWwS0KwXbHbQUZP2M1+x3pUgbyrhA/vjeGG9tcNjs9M6maNnb2B4FnXTeR1Tw7TF6DZldL0ZRcHuMIs2WRn9LW10DWe/ei9JQJ4ELUkjOsxJ7m6+QYbnXvbTY2Ow6D6FHh/7lTTBZZSVLOtqB8g4iCCHzeZK+dC1Y38ymWJ3vb5SBnteXszG7cAfyXB6EYzgPBD/URrIP3Wr6u+OqQ9OmDF94qRp5JtZj/9u9sx5C/icym8TiHvgB8gGOwAEwU4c/M4nELJA1RaoJelK5ZPTbBAIlYikk0WuCInpvPM3e2CJ+16ASv2UpGqjUBAIkMRRWhRNSeqtK6QAyGYBkJXxUyYgEkE7ZYLxAQJIVjbPWkkXx4+ZIJRzr1gnnuT0TQ2Xp3rTPZ5kI5Hl5NZ2wZDslYJtjN4kb/+ILklMTUvtHyFp1rT0tPw0qqdJaUlpzsxM6BvJlJ0W3iDhg5ZN3bwwdMsfKruRW2ZQbuRlt9evdcorVpPyolGwuJT/dUDsCHUKOz4AWfRHQvA065Z1snHLxtW7/oddaNewgZANO4LY+n9OPN+rQSxmD80rC7ed1/Rm9/puaEacl3tH9TwUsfXIpYPVzprl6o4iBXdYT0AUtDAtYc3y+EuJtrjkUwGEVlI650ylKvE+5ABA/HNTwuf9lc+BgItUcf0/AgZwQedwuks0ypTyaYjSqY+iqLe60l3E5aIWOZ1mxPuV70toergeGwR4g0v8V2eKi0otVJZJ05xV7GHcsHQO+0ESk9LSjDup6913x/KzVKdeX9THFGzb1v5TDDfpQ45bECoJ9+43cBcf0nCXXr/F8/43notvxJ6rVEnqc1TWG05X9cp+AAQRKWiHl2Knck80KgqljCAC4Aq1QvJpPHP6XaxCImp1FiUv6pwAUXstt2Ud9NrbHGJCAsQx9ufEKktsFtJBzroOMYF9EK/V+GK1mv8PflNJUQAAAAABAAAAARmahXJJOF8PPPUACQgAAAAAAMk1MYsAAAAAyehMTPua/dUJoghiAAAACQACAAAAAAAAeAFjYGRg4Oj9u4KBgXPN71n/qjkXAUVQwU0Ap6sHhAB4AW2SA6wYQRRF786+2d3atm3b9ldQ27atsG6D2mFt2zaC2ra2d/YbSU7u6C3OG7mIowAgGQFlKIBldiXM1CVQQRZiurMEffRtDLVOYqbqhBBSS/ohgnt9rG+ooxYiTOXDMvUBGbnWixwgPUgnUoLMJCOj5n1IP3Oe1ImajzZpD0YOtxzG6rSALoOzOiUm6ps4K8NJPs6vc/4cZ1UBv4u85FoRnHWr4azjkRqYKFej8hP3eqCfDER61uyT44DbBzlkBTwZD8h8/sMabOD3ZmFWkAiUs5f4f2SFNZfv6iTPscW+jOHynEzEcLULuaQbivCdW5SDNcrx50uFYLzFHYotZl1umvNM1tgNWX+V/3gdebi3ThTgVEMWKYci4kHZhxBie3TYx3rHbGr+Pdo7x4dIHTKe5DFn+O/j+W2VnE3ooW6isf0LIUENvZs1gf/LHojJwdpplCP5gn/5gi26FoYa19ZVFOJ6Sxuoz/q2Ti20IKVJdnqvYJwnhfPH/2f6YHoQF30aZaK9J8T026RxH5fA/WPW/8IW4zkpnIfoFLifGB86v0ffm5nbyRs5iaHR3hNBD0HSfTzoPugRM+hdN0x052KoHLBS0tdgpidAiEesDsgWYO73RWQz2LWIwjqnMe/uYISQtlbyf2NlT9Q9PoBcBnrO6I5ELoMeyHkNnIXGdv809H/DXNOTeAEc0jWMJFcQxvFnto/5LjEvHrdbmh2Kji9aPL4839TcKPNAa6mlZUyOmZk6lzbPJ3bo56//Cz+Vaqqrat5rY8x7xnzxl3nvo+27jFnz8c/mI9Nmh2XBdMsilrBitsnD9rI8aiN5DI/jSftC9mIf9pMfIB4kHiI+hWfQY5aPAYYYYYwpcyfpMMX0aZzBWZzDeVygchGXcBlX8ApexWt4HW/gLbzNbnfwLt7DJ/p0TX4+Uucji1hCnY/U+cijVB7D46jzkb3Yh/3kB4gHiYeIT+EZ9JjlY4AhRhhjytxJOkwxfRpncBbncB4XqFzEJVzGFbyCV/EaXscbeAtvs9sdvIv3cjmftWavuWs2mg6byt3ooIsFOyx77Kos2kiWsIK/UVPDOjawiQmO4CgdxnAcJzClz2PVbNKsy2ZzvoncjQ66qE2kNpHaRJawgr9RU8M6NrCJCY6gNpFjOI4TmNIn36TNfGSH5RrssKtyN+59b410iF0sUFO0l2UJtY/8jU9rWMcGNjHBEUypf0z8mm7vZLvZaC/LzdhmV2XBvpBF25IlLJOvEFfRI+NjgCFGGGNK5Rs6Z7Ij/45yNzro4m9Ywzo2sIkJjuBj2ZnvLDdjGxntLLWzLGGZfIW4ih4ZHwMMMcIYUyq1s8xkl97bH0y3JkZyM36j/+58rvTQxwBDjDDGNzyVyX35Ccjd6KCLv2EN69jAJiY4go/lfr05F+Ua7CCzGx10sYA9tiWLxCWs2BfyN+Ia1rGBTUxwBEfpMIbjOIEpfdjHvGaTd9LJb0duRp2S1O1I3Y4sYZl8hbiKHhkfAwwxwhhTKt/QOZPfmY3//Ss3Y5tNpTpL9ZQeGR8DDDHCGN/wbCbdfHO5GbW51OZSm8sSlslXiKvokfExwBAjjDGlUpvLTBY0K5KbiDcT672SbXZY6k7lbnTQxQI1h+1FeZTKY3gcT2KvTWUf9pMZIB4kHiI+xcQzxGfpfA7P4wW8yG4eT/kYYIgRxvgb9TWsYwObmOAITlI/xf7TOIOzOIfzuEDlIi7hMq7gFbyK1/A63sBbeJtvdwfv4j28zyaP8QmVL/imL/ENJ5PJHt3RqtyMbbYlPfQxwBAjjPEN9ZksqkMqN6PuV7bZy7LDtuRudNDFwzx1FI/hcTzJp73Yh/3kB4gHiYeIT+EZ9JjlY4AhRhjjb1TWsI4NbGKCIzjJlCmcxhmcxTmcxwVcxCVcxhW8glfxGl7HG3gLbzPxDt7Fe/gY/+egvq0YCAEoCNa1n+KVyTUl3Q0uIhoe+3DnRfV7nXGOc5zjHOc4xznOcY5znOMc5zjHOc5xjnOc4xznOMc5znGOc5zjHOc4xznOcY5znOMc5zjHOc5xjnOc4xznOMc5znGOc5zjHOc4xznOcY5znOM8XZouTZemS1OAKcAUYAowBZgCTAHm3x31O7p3vNf5c1iXeBkEAQDFcbsJX0IqFBwK7tyEgkPC3R0K7hrXzsIhePPK/7c77jPM1yxSPua0WmuDzNcuNmuLtmq7sbyfsUu7De/xu9fvvvDNfN3ioN9j5pq0ximd1hmd1TmlX7iky7qiq7qmG3pgXYd6pMd6oqd6pud6oZd6pdd6p/f6oI/6pC/KSxvf9F0/1LFl1naRcwwzrAu7AHNarbW6oEu6rCu6qmu6ob9Y7xu+kbfHH1ZopCk25RVrhXKn4LCO6KiOGfvpd+R3is15xXmVWKGRptgaysQKpUwc1hEdVcpEysTI7xTbKHMcKzTSFDtCmVihkab4z0FdI0QQBAEUbRz6XLh3Lc7VcI/WN54IuxXFS97oH58+MBoclE1usbHHW77wlW985wcHHHLEMSecsUuPXMNRqfzib3pcllj5xd+0lSVW5nNIL3nF6389h+Y5NG3Thja0oQ1taEMb2tCGNrQn+QwjrcwxM93gJre4Y89mvsdb3vGeD3zkE5/5wle+8Z0fHHDIEceccMaOX67wNz3747gObCQAQhCKdjlRzBVD5be7rwAmfOMQsUvPLj279OzSYBks49Ibl97In/HCuNDGO+NOW6qlWqqlWqqlWqqlWqqYUkwpphTzifnEfII92IM92IM92IM92IM92IM92I/D4/A4PA6Pw+PwODwOj8M/f7kaaDXQyt7K3mqglcCVwNVAq4FWA60GWglZCVkJWQlZCVkJWQlZDbQyqhpoNdAPh3NAwCAAwwDM+7b2sg8kCjIO4zAO4zAO4zAO4zAO4zAO4zAO4zAO4zAO4zAO4zAO47AO67AO67AO67AO67AO67AO67AO67AO67AO67AO67AO63AO53AO53AO53AO53AO53AO53AO53AO53AO53AO53AO5xCHOMQhDnGIQxziEIc4xCEOcYhDHOIQhzjEIQ5xiEMd6lCHOtShDnWoQx3qUIc61KEOdahDHepQhzrUoQ6/h+P6RpIjiKEoyOPvCARUoK9LctP5ZqXTop7q/6H/0H+4P9yfPz82bdm2Y9ee/T355bS3/divDW9reFtDb4beDL0ZejP0ZujN0JuhN0Nvht4MvRl6M/Rm6M3w1of3PVnJSlaykpWsZCUrWclKVrKSlaxkJStZySpWsYpVrGIVq1jFKlaxilWsYhWrWMUqVrGa1axmNatZzWpWs5rVrGY1q1nNalazmtWsYQ1rWMMa1rCGNaxhDWtYwxrWsIY1rGENa1nLWtaylrWsZS1rWcta1rKWtaxlLWtZyzrWsY51rGMd61jHOtaxjnWsYx3rWMc61rEeTf1o6kdTP/84rpMqCKAYhmH8Cfy2JjuLCPiYPDH1Y+rH1I+pH1M/pn5M/Zh6FEZhFEZhFEZhFEZhFEZhFFZhFVZhFVZhFVZhFVZhFVbhFE7hFE7hFE7hFE7hFE7hFCKgCChPHQFlc7I52ZxsTgQUAUVAEVAEFAFFQBFQBBQBRUARUAQUAUVAEVAEFAFFQBFQti5bl63L1mXrsnXZuggoAoqAIqAIKAKKgCKgCCgCioAioAgoAoqAIqAIKAKKgCKgCCgCyt5GQBFQBPTlwD7OEIaBKAxSOrmJVZa2TsJcwJ6r0/+9sBOGnTDshOF+DndyXG7k7vfh9+n35fft978Thp2wKuqqqKtarmq58cYbb7zzzjvvfPDBBx988sknn3zxxRdfPHnyVPip8FPhp8JPhZ8KP78czLdxBDAMAMFc/bdAk4AERoMS5CpQOW82uWyPHexkJzvZyU52spOd7GQnu9jFLnaxi13sYhe72MVudrOb3exmN7vZzW52s8EGG2ywwQYbbLDBBnvZy172spe97GUve9nLJptssskmm2yyySabbLHFFltsscUWW2yxxX6+7P+rH/qtf6+2Z3u2Z3u2Z3u2Z3u2Z3s+O66jKoYBGASA/iUFeLO2tqfgvhIgVkOshvj/8f/jF8VqiL8dqyG+d4klllhiiSWWWGKJJY444ogjjjjiiCOO+Pua0gPv7paRAHgBLcEDFOsGAADAurFtJw/bt23btm3btm3btm3btq27UCik/1sq1CH0I9wl/DTSONInsjxyKcpGc0VrRNtGx0dXRF/FpFiV2KbYl3j++Jz4vkTaxKjEgcSXpJzMm6yb3ALkAnoCV0ARLAcOBjdCAJQJqgWNhJZDT2EbbgTPhz8h+ZFJyDbkFSqgVdGh6Br0BhbFFCwHVhNrj43DXuH58V74WcIkahHvyDRkLXIGeY18SxWl+lMHaIVuSc+h3zHpmNbMJOYuy7DF2E7sFvYMJ3Clf+3DHecNvjm/m38g1BYmioxYS5wqbhZ3S0Wl2tJkab50U04pl5CHy9vlmwqlZFJaK4uVnco55YlaUK2kNla7qEPV6epi9aMW01jN0zJohbRZ2mptj3ZWu6e91wE9vT5LX63v0c/q9/UPRiZjprHS2GmcNG4ar8yIOcycZC4yN5mHzMvmE/OrhVq6NcCaYC2wNlgHrAvWQ/t/e6w9115r77XP2fecrE4xp65zwM3lNnZnuBfdZ17E071sXj6vrTfP2+Hd8F74lJ/eL+Hv86/6D/23Qfogf1A+qB10CAYGk4LFwdaf2C+JfQAAAAABAAAA3QCKABYAVgAFAAIAEAAvAFwAAAEOAPgAAwABeAFljgNuBEAUhr/ajBr3AHVY27btds0L7MH3Wysz897PZIAO7mihqbWLJoahiJvpl+Wxc4HRIm6tyrQxwkMRtzNIooj7uSDDMRE+Cdk859Ud50z+TZKAPMaqyjsm+HDGzI37GlqiNTu/tj7E00x5rrBBXDWMWdUJdMrtUveHhCfCHJOeNB4m9CK+d91PWZgY37oBfov/iTvjKgfsss4mR5w7x5kxPZUFNtEoQ3gBbMEDjJYBAADQ9/3nu2zbtm3b5p9t17JdQ7Zt21zmvGXXvJrZe0LA37Cw/3lDEBISIVKUaDFixYmXIJHEkkgqmeRSSCmV1NJIK530Msgok8yyyCqb7HLIKZfc8sgrn/wKKKiwIooqprgSSiqltDLKKqe8CiqqpLIqqqqmuhpqqqW2Ouqqp74GGmqksSaaaqa5FlpqpbU22mqnvQ466qSzLrrqprs9NpthprNWeWeWReZba6ctQYR5QaTplvvhp4VWm+Oyt75bZ5fffvljk71uum6fHnpaopfbervhlvfCHnngof36+Gappx57oq+PPpurv34GGGSgwTYYYpihhhthlJFGG+ODscYbZ4JJJjphoykmm2qaT7445ZkDDnrujRcOOeyY46444qirZtvtnPPOBFG+BtFBTBAbxAXxQYJC7rvjrnv/xpJXmpPDXpqXaWDg6MKZX5ZaVJycX5TK4lpalA8SdnMyMITSRjxp+aVFxaUFqUWZ+UVQQWMobcKUlgYAHQ14sAAAeAFNSzVaxFAQfhP9tprgntWkeR2PGvd1GRwqaiyhxd1bTpGXbm/BPdAbrFaMzy+T75H4YoxiYFN0UaWoDWhP2IGtZtNuNJMW0fS8E3XHLHJEiga66lFTq0cNtR5dXhLRpSbXJTpJB5U00XSrgOqEGqjqwvxA9GsekiJBw2KIekUPdQCSJZAQ86hE8QMVxDoqhgKMQDDaZ6csYH9Msxic9YIOVXgLK2XO01WzXkrLSGFTwp10yq05WdyQxp1ktLG5FgK8rF8/P7PpkbQcLa/J2Mh6Wu42D2sk7GXT657H+Y7nH/NW+Nzz+f9ov/07DXE7QQYAAA==) format("woff")}@font-face{font-family:"Open Sans";font-style:normal;font-weight:700;src:local("Open Sans Bold"),local("OpenSans-Bold"),url(data:font/woff;base64,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) format("woff")}*{box-sizing:border-box}body{padding:0;margin:0;font-family:"Open Sans","Helvetica Neue",Helvetica,Arial,sans-serif;font-size:16px;line-height:1.5;color:#606c71}a{color:#1e6bb8;text-decoration:none}a:hover{text-decoration:underline}.page-header{color:#fff;text-align:center;background-color:#159957;background-image:linear-gradient(120deg,#155799,#159957);padding:1.5rem 2rem}.page-header :last-child{margin-bottom:.5rem}@media screen and (max-width:42em){.page-header{padding:1rem 1rem}}.project-name{margin-top:0;margin-bottom:.1rem;font-size:2rem}@media screen and (max-width:42em){.project-name{font-size:1.75rem}}.project-tagline{margin-bottom:2rem;font-weight:400;opacity:.7;font-size:1.5rem}@media screen and (max-width:42em){.project-tagline{font-size:1.2rem}}.project-author,.project-date{font-weight:400;opacity:.7;font-size:1.2rem}@media screen and (max-width:42em){.project-author,.project-date{font-size:1rem}}.main-content,.toc{max-width:64rem;padding:2rem 4rem;margin:0 auto;font-size:1.1rem}.toc{padding-bottom:0}.toc .toc-box{padding:1.5rem;background-color:#f3f6fa;border:solid 1px #dce6f0;border-radius:.3rem}.toc .toc-box .toc-title{margin:0 0 .5rem;text-align:center}.toc .toc-box>ul{margin:0;padding-left:1.5rem}@media screen and (min-width:42em) and (max-width:64em){.toc{padding:2rem 2rem 0}}@media screen and (max-width:42em){.toc{padding:2rem 1rem 0;font-size:1rem}}.main-content :first-child{margin-top:0}@media screen and (min-width:42em) and (max-width:64em){.main-content{padding:2rem}}@media screen and (max-width:42em){.main-content{padding:2rem 1rem;font-size:1rem}}.main-content img{max-width:100%}.main-content h1,.main-content h2,.main-content h3,.main-content h4,.main-content h5,.main-content h6{margin-top:2rem;margin-bottom:1rem;font-weight:400;color:#159957}.main-content p{margin-bottom:1em}.main-content code{padding:2px 4px;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;color:#567482;background-color:#f3f6fa;border-radius:.3rem}.main-content pre{padding:.8rem;margin-top:0;margin-bottom:1rem;font:1rem Consolas,"Liberation Mono",Menlo,Courier,monospace;color:#567482;word-wrap:normal;background-color:#f3f6fa;border:solid 1px #dce6f0;border-radius:.3rem;line-height:1.45;overflow:auto}@media screen and (max-width:42em){.main-content pre{font-size:.9rem}}.main-content pre>code{padding:0;margin:0;color:#567482;word-break:normal;white-space:pre;background:0 0;border:0}@media screen and (max-width:42em){.main-content pre>code{font-size:.9rem}}.main-content pre code,.main-content pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.main-content pre code:after,.main-content pre code:before,.main-content pre tt:after,.main-content pre tt:before{content:normal}.main-content ol,.main-content ul{margin-top:0}.main-content blockquote{padding:0 1rem;margin-left:0;color:#819198;border-left:.3rem solid #dce6f0;font-size:1.2rem}.main-content blockquote>:first-child{margin-top:0}.main-content blockquote>:last-child{margin-bottom:0}@media screen and (max-width:42em){.main-content blockquote{font-size:1.1rem}}.main-content table{width:100%;overflow:auto;word-break:normal;word-break:keep-all;-webkit-overflow-scrolling:touch;border-collapse:collapse;border-spacing:0;margin:1rem 0}.main-content table th{font-weight:700;background-color:#159957;color:#fff}.main-content table td,.main-content table th{padding:.5rem 1rem;border-bottom:1px solid #e9ebec;text-align:left}.main-content table tr:nth-child(odd){background-color:#f2f2f2}.main-content dl{padding:0}.main-content dl dt{padding:0;margin-top:1rem;font-size:1rem;font-weight:700}.main-content dl dd{padding:0;margin-bottom:1rem}.main-content hr{height:2px;padding:0;margin:1rem 0;background-color:#eff0f1;border:0}</style>





</head>

<body>




<section class="page-header">
<h1 class="title toc-ignore project-name">Resampling Methods</h1>
<h4 class="author project-author">Exercises with solutions</h4>
<h4 class="date project-date">2025-06-29</h4>
</section>



<section class="main-content">
<style>
body {
max-width: none !important;
width: 100% !important;
word-break: normal !important;
overflow-wrap: break-word !important;
white-space: normal !important;
}
body .container,
body .container-fluid,
body .main-container {
max-width: 100% !important;
width: 100% !important;
margin: 0 auto;
padding-left: 2em;
padding-right: 2em;
box-sizing: border-box;
}
.tab-button {
background-color: #eee;
border: none;
padding: 10px;
cursor: pointer;
font-weight: bold;
}
.tab-button.active {
background-color: #ccc;
}
.tab-content {
display: none;
padding: 10px;
border-top: 1px solid #ccc;
}
.tab-content.active {
display: block;
}
button {
margin-top: 10px;
margin-bottom: 10px;
padding: 8px 16px;
font-size: 15px;
border: 1px solid #0072B2;
background-color: #0072B2;
color: white;
border-radius: 5px;
cursor: pointer;
transition: background-color 0.3s ease;
}
button:hover {
background-color: #005b8a;
}
.solution {
background-color: white;
border-left: 4px solid #0072B2;
padding: 10px;
margin-top: 5px;
margin-bottom: 20px;
}
</style>
</style>
<div>
<p><button class="tab-button active" onclick="showTab(&#39;r1&#39;)">R</button>
<button class="tab-button" onclick="showTab(&#39;py1&#39;)">Python</button></p>
</div>
<div id="r1" class="tab-content active">
<div id="exercise-1" class="section level1">
<h1>Exercise 1</h1>
<p>The <code>diamonds</code> dataset contains prices and attributes of
over <span class="math inline">\(50,000\)</span> diamonds, including
characteristics such as carat size, cut, color, and clarity. In R, this
dataset is available through the <code>ggplot2</code> package. You can
load it using <code>data(diamonds, package = &quot;ggplot2&quot;)</code>.</p>
<p>The dataset includes the following variables:</p>
<ul>
<li><p><strong>price</strong>: price (US dollars),</p></li>
<li><p><strong>carat</strong>: weight of the diamond,</p></li>
<li><p><strong>cut</strong>: quality of the cut (<code>Fair</code>,
<code>Good</code>, <code>Very Good</code>, <code>Premium</code>,
<code>Ideal</code>),</p></li>
<li><p><strong>color</strong>: diamond color, from <code>J</code>
(worst) to <code>D</code> (best),</p></li>
<li><p><strong>clarity</strong>: measurement of how clear the diamond
is,</p></li>
<li><p><strong>x</strong>, <strong>y</strong>, <strong>z</strong>:
physical dimensions - <code>length</code>, <code>width</code>,
<code>depth</code> (mm).</p></li>
</ul>
<ol style="list-style-type: decimal">
<li><p>Using only complete cases, fit polynomial regression models of
degrees 1 through 5 to predict <code>price</code> based on
<code>carat</code> (i.e., regress price on <code>carat</code>,
<code>carat</code>^2, etc.).</p></li>
<li><p>Use 10-fold cross-validation (e.g., with the <code>boot</code> or
<code>caret</code> package) to estimate the test MSE for each polynomial
degree.</p></li>
<li><p>Create a plot showing polynomial degree on the x-axis and the
corresponding cross-validated MSE on the y-axis.</p></li>
<li><p>Which polynomial degree gives the lowest estimated test error?
What does this suggest about the relationship between <code>carat</code>
and <code>price</code>?</p></li>
</ol>
<button onclick="toggleSolution(this)">
Show/Hide Solution
</button>
<div class="solution" style="display:none;">
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># Load required libraries</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="fu">library</span>(tibble)</span></code></pre></div>
<p>We begin by loading <code>diamonds</code> dataset, which is available
in the <code>ggplot2</code> package. Using <code>na.omit()</code> we can
exclude all observations with at least one missing value. For
convenience, we store <code>diamonds</code> dataset as
<code>data.frame</code> object.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Use ggplot2&#39;s diamonds dataset</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;diamonds&quot;</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="co"># Remove observations with missing values </span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>diamonds <span class="ot">&lt;-</span> <span class="fu">na.omit</span>(diamonds)</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>X <span class="ot">&lt;-</span> diamonds<span class="sc">$</span>carat</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>y <span class="ot">&lt;-</span> diamonds<span class="sc">$</span>price</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="co"># Create data frame, set seed for reproducibility</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">103</span>)</span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">carat =</span> X, <span class="at">price =</span> y)</span></code></pre></div>
<p>To fit linear regression models of
<code>price</code>~<code>carat</code>^d, for <span class="math inline">\(d=1,2,3,4,5\)</span> we can use
<code>poly()</code> function. You can also just create new variables
corresponding to higher powers of <code>carat</code> and use them.</p>
<p>For each degree, we do 10-fold cross validation. In the solution
below it is done manually but you can use existing packages. In the code
below we split observations into folds in the following way:</p>
<ul>
<li><p>We repeat vector <span class="math inline">\((1,2,\ldots,10)\)</span> until its length exceeds
amount of observations <span class="math inline">\(n\)</span> and we
keep only first <span class="math inline">\(n\)</span>
elements.</p></li>
<li><p>We shuffle this sequence and assign <span class="math inline">\(i-th\)</span> observation to the fold numbered by
value at <span class="math inline">\(i-th\)</span> coordinate.</p></li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># Define degrees (you can experiment with broader spectrum of values)</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>degrees <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="co"># Prepare results container - we will store results in this object</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>mse_scores <span class="ot">&lt;-</span> <span class="fu">numeric</span>(<span class="fu">length</span>(degrees))</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="co"># Loop through polynomial degrees</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="cf">for</span> (d <span class="cf">in</span> degrees) {</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>  <span class="co"># Create polynomial terms, i.e. carat^d</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>  formula <span class="ot">&lt;-</span> <span class="fu">as.formula</span>(<span class="fu">paste</span>(<span class="st">&quot;price ~ poly(carat,&quot;</span>, d, <span class="st">&quot;, raw = TRUE)&quot;</span>))</span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>  <span class="co"># Manually perform 10-fold CV</span></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(df)</span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>  <span class="co"># Create folds for CV</span></span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a>  folds <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">length.out =</span> n))</span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>  <span class="co"># We will store MSE for each fold in this object</span></span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a>  fold_mse <span class="ot">&lt;-</span> <span class="fu">numeric</span>(<span class="dv">10</span>)</span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a>  <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>) {</span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a>    <span class="co"># Select data to train model on</span></span>
<span id="cb3-21"><a href="#cb3-21" tabindex="-1"></a>    train_data <span class="ot">&lt;-</span> df[folds <span class="sc">!=</span> k, ]</span>
<span id="cb3-22"><a href="#cb3-22" tabindex="-1"></a>    <span class="co"># Remaining data for validation</span></span>
<span id="cb3-23"><a href="#cb3-23" tabindex="-1"></a>    test_data <span class="ot">&lt;-</span> df[folds <span class="sc">==</span> k, ]</span>
<span id="cb3-24"><a href="#cb3-24" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" tabindex="-1"></a>    <span class="co"># Train the model on train_data</span></span>
<span id="cb3-26"><a href="#cb3-26" tabindex="-1"></a>    model <span class="ot">&lt;-</span> <span class="fu">lm</span>(formula, <span class="at">data =</span> train_data)</span>
<span id="cb3-27"><a href="#cb3-27" tabindex="-1"></a>    <span class="co"># Make predictions for validation set</span></span>
<span id="cb3-28"><a href="#cb3-28" tabindex="-1"></a>    preds <span class="ot">&lt;-</span> <span class="fu">predict</span>(model, <span class="at">newdata =</span> test_data)</span>
<span id="cb3-29"><a href="#cb3-29" tabindex="-1"></a>    <span class="co"># Store MSE for this fold</span></span>
<span id="cb3-30"><a href="#cb3-30" tabindex="-1"></a>    fold_mse[k] <span class="ot">&lt;-</span> <span class="fu">mean</span>((test_data<span class="sc">$</span>price <span class="sc">-</span> preds)<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb3-31"><a href="#cb3-31" tabindex="-1"></a>  }</span>
<span id="cb3-32"><a href="#cb3-32" tabindex="-1"></a>  <span class="co"># Average MSE over folds and store</span></span>
<span id="cb3-33"><a href="#cb3-33" tabindex="-1"></a>  mse_scores[d] <span class="ot">&lt;-</span> <span class="fu">mean</span>(fold_mse)</span>
<span id="cb3-34"><a href="#cb3-34" tabindex="-1"></a>}</span></code></pre></div>
<p>We visualize how the test error (measured by 10-fold cross-validated
MSE) changes with the degree of the polynomial used to model the
relationship between <code>price</code> and <code>carat</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Plot MSE vs Degree </span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>results_df <span class="ot">&lt;-</span> <span class="fu">tibble</span>(<span class="at">Degree =</span> degrees, <span class="at">MSE =</span> mse_scores <span class="sc">/</span> <span class="fl">1e6</span>)</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="fu">ggplot</span>(results_df, <span class="fu">aes</span>(<span class="at">x =</span> Degree, <span class="at">y =</span> MSE)) <span class="sc">+</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">color =</span> <span class="st">&quot;#1f77b4&quot;</span>, <span class="at">size =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="dv">3</span>, <span class="at">color =</span> <span class="st">&quot;#1f77b4&quot;</span>) <span class="sc">+</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>  <span class="fu">labs</span>(</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">&quot;Test Error vs. Polynomial Degree&quot;</span>,</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>    <span class="at">x =</span> <span class="st">&quot;Polynomial Degree&quot;</span>,</span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a>    <span class="at">y =</span> <span class="fu">expression</span>(<span class="st">&quot;10-fold Cross-Validated MSE (&quot;</span><span class="sc">*</span><span class="dv">10</span><span class="sc">^</span><span class="dv">6</span><span class="sc">*</span> <span class="st">&quot;)&quot;</span>)</span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>  <span class="fu">theme_classic</span>() <span class="sc">+</span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a>  <span class="fu">theme</span>(</span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a>    <span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>, <span class="at">size =</span> <span class="dv">14</span>),</span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a>    <span class="at">axis.title =</span> <span class="fu">element_text</span>(<span class="at">size =</span> <span class="dv">12</span>),</span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a>    <span class="at">axis.text =</span> <span class="fu">element_text</span>(<span class="at">size =</span> <span class="dv">10</span>),</span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a>    <span class="at">panel.border =</span> <span class="fu">element_rect</span>(<span class="at">color =</span> <span class="st">&quot;black&quot;</span>, <span class="at">fill =</span> <span class="cn">NA</span>, <span class="at">linewidth =</span> <span class="fl">0.5</span>),</span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a>    <span class="at">panel.grid.major =</span> <span class="fu">element_line</span>(<span class="at">color =</span> <span class="st">&quot;grey85&quot;</span>, <span class="at">size =</span> <span class="fl">0.3</span>),</span>
<span id="cb4-19"><a href="#cb4-19" tabindex="-1"></a>    <span class="at">panel.grid.minor =</span> <span class="fu">element_blank</span>()</span>
<span id="cb4-20"><a href="#cb4-20" tabindex="-1"></a>  )</span></code></pre></div>
<p><img role="img" src="data:image/png;base64,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" /><!-- --></p>
<p>We determine the optimal polynomial degree by selecting the one that
yields the lowest average MSE across all folds in 10-fold
cross-validation.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Find best degree and print it</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>best_degree <span class="ot">&lt;-</span> degrees[<span class="fu">which.min</span>(mse_scores)]</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>best_mse <span class="ot">&lt;-</span> <span class="fu">min</span>(mse_scores)</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="fu">paste</span>(<span class="st">&quot;Best polynomial degree:&quot;</span>, best_degree, <span class="st">&quot;with MSE:&quot;</span>, <span class="fu">round</span>(best_mse, <span class="dv">2</span>))</span></code></pre></div>
<pre><code>## [1] &quot;Best polynomial degree: 4 with MSE: 2073225.57&quot;</code></pre>
<p>It is clear that regressing <code>price</code> on
<code>carat</code><span class="math inline">\(^4\)</span> yields the
lowest average MSE among the polynomial degrees considered. However,
this may not represent the global minimum, and it is worth exploring
higher-degree polynomials to see if further improvements in model
performance can be achieved.</p>
</div>
</div>
<div id="exercise-2" class="section level1">
<h1>Exercise 2</h1>
<p>The <code>penguins</code> dataset contains size measurements for
three penguin species observed on islands in the Palmer Archipelago,
Antarctica. This dataset is part of the <code>palmerpenguins</code>
package.</p>
<p>The dataset includes the following variables:</p>
<ul>
<li><p><strong>species</strong>: penguin species (<code>Adelie</code>,
<code>Gentoo</code>, <code>Chinstrap</code>),</p></li>
<li><p><strong>island</strong>: island where the penguin was
observed,</p></li>
<li><p><strong>bill_length_mm</strong>: length of the bill
(millimeters),</p></li>
<li><p><strong>bill_depth_mm</strong>: depth of the bill
(millimeters),</p></li>
<li><p><strong>flipper_length_mm</strong>: length of the flipper
(millimeters),</p></li>
<li><p><strong>body_mass_g</strong>: body mass (grams),</p></li>
<li><p><strong>sex</strong>: sex of the penguin,</p></li>
<li><p><strong>year</strong>: year of observation.</p></li>
</ul>
<ol style="list-style-type: decimal">
<li><p>Fit a linear regression model to predict <code>body_mass_g</code>
using <code>bill_length_mm</code> and <code>flipper_length_mm</code> as
predictors. Use only complete cases.</p></li>
<li><p>Use the validation set approach: randomly split the data into a
training set <span class="math inline">\((70%)\)</span> and a test set
<span class="math inline">\((30%)\)</span>. Fit the model on the
training set and compute the test Mean Squared Error (MSE).</p></li>
<li><p>Repeat <strong>Exercise 2.2.</strong> fifty times using different
random seeds. Report the average test MSE and its standard deviation
across all repetitions.</p></li>
<li><p>Use 10-fold cross-validation (<code>cv.glm</code> from the
<code>boot</code> package) to estimate the test error of the same model.
Compare this with the average test MSE from repeated
validation.</p></li>
<li><p>Use the bootstrap (<code>boot</code> package) to estimate the
standard errors of the regression coefficients. Compare them with the
standard errors from <code>summary()</code>.</p></li>
</ol>
<button onclick="toggleSolution(this)">
Show/Hide Solution
</button>
<div class="solution" style="display:none;">
<p>We start by loading <code>penguins</code> dataset. We clean the data
by removing rows that contain missing values in the variables of
interest (<code>body_mass_g</code>, <code>bill_length_mm</code>,
<code>flipper_length_mm</code>).</p>
<p>Next, we separate the dataset into:</p>
<ul>
<li><p><strong>X</strong> - a data frame containing the predictor
variables <code>bill_length_mm</code> and
<code>flipper_length_mm</code>,</p></li>
<li><p><strong>y</strong> - a vector containing the response variable
<code>body_mass_g</code>.</p></li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">library</span>(boot)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="fu">library</span>(palmerpenguins)</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co"># Load and clean data</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="co"># We remove only observations that have missing values in relevant columns</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>penguins <span class="ot">&lt;-</span> <span class="fu">na.omit</span>(penguins[, <span class="fu">c</span>(<span class="st">&quot;body_mass_g&quot;</span>, <span class="st">&quot;bill_length_mm&quot;</span>, <span class="st">&quot;flipper_length_mm&quot;</span>)])</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="co"># Separate predictors and target</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>X <span class="ot">&lt;-</span> penguins[, <span class="fu">c</span>(<span class="st">&quot;bill_length_mm&quot;</span>, <span class="st">&quot;flipper_length_mm&quot;</span>)]</span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a>y <span class="ot">&lt;-</span> penguins<span class="sc">$</span>body_mass_g</span></code></pre></div>
<p>We fit model <code>body_mass_g</code>~<code>bill_length_mm</code> +
<code>flipper_length_mm</code> using <code>lm()</code> function.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># Fit a linear model to the full clean dataset</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>model_full <span class="ot">&lt;-</span> <span class="fu">lm</span>(body_mass_g <span class="sc">~</span> bill_length_mm <span class="sc">+</span> flipper_length_mm, <span class="at">data =</span> penguins)</span></code></pre></div>
<p>We perform a repeated validation set approach to estimate the
prediction error of our linear regression model.</p>
<p>The dataset is split randomly <span class="math inline">\(50\)</span>
times, with <span class="math inline">\(70\%\)</span> of the data used
for training and <span class="math inline">\(30\%\)</span> for testing
in each iteration. A different seed is set for each iteration to ensure
randomness and reproducibility.</p>
<p>In each iteration:</p>
<ul>
<li><p>A linear regression model is fit using only the training data to
predict body_mass_g from bill_length_mm and flipper_length_mm.</p></li>
<li><p>The model’s predictions are then evaluated on the test set using
Mean Squared Error (MSE).</p></li>
<li><p>The computed MSE is stored for later analysis.</p></li>
</ul>
<p>After all iterations we compute the average MSE to estimate the
model’s typical prediction error on unseen data.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Repeated validation set approach</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="co"># We will use mse_list to store mse in each iteration</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>mse_list <span class="ot">&lt;-</span> <span class="fu">numeric</span>(<span class="dv">50</span>)</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(penguins)</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="cf">for</span> (seed <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">50</span>) {</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>  <span class="co"># Set seed for reproducibility</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>  <span class="fu">set.seed</span>(seed)</span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>  <span class="co"># Randomly keep 70% of data to train the model on</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>  train_idx <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>n, <span class="at">size =</span> <span class="fu">floor</span>(<span class="fl">0.7</span> <span class="sc">*</span> n))</span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a>  train <span class="ot">&lt;-</span> penguins[train_idx, ]</span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a>  <span class="co"># Remaining 30% will be for testing</span></span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a>  test <span class="ot">&lt;-</span> penguins[<span class="sc">-</span>train_idx, ]</span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" tabindex="-1"></a>  <span class="co"># Linear regression model is trained only using train data</span></span>
<span id="cb9-17"><a href="#cb9-17" tabindex="-1"></a>  model <span class="ot">&lt;-</span> <span class="fu">lm</span>(body_mass_g <span class="sc">~</span> bill_length_mm <span class="sc">+</span> flipper_length_mm, <span class="at">data =</span> train)</span>
<span id="cb9-18"><a href="#cb9-18" tabindex="-1"></a>  <span class="co"># Test data is used for predictions</span></span>
<span id="cb9-19"><a href="#cb9-19" tabindex="-1"></a>  predictions <span class="ot">&lt;-</span> <span class="fu">predict</span>(model, test)</span>
<span id="cb9-20"><a href="#cb9-20" tabindex="-1"></a>  </span>
<span id="cb9-21"><a href="#cb9-21" tabindex="-1"></a>  <span class="co"># MSE on test data is stored</span></span>
<span id="cb9-22"><a href="#cb9-22" tabindex="-1"></a>  mse_list[seed] <span class="ot">&lt;-</span> <span class="fu">mean</span>((test<span class="sc">$</span>body_mass_g <span class="sc">-</span> predictions)<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb9-23"><a href="#cb9-23" tabindex="-1"></a>}</span>
<span id="cb9-24"><a href="#cb9-24" tabindex="-1"></a></span>
<span id="cb9-25"><a href="#cb9-25" tabindex="-1"></a><span class="co"># Average MSE over all 50 iterations, we also keep standard deviation</span></span>
<span id="cb9-26"><a href="#cb9-26" tabindex="-1"></a>avg_mse <span class="ot">&lt;-</span> <span class="fu">mean</span>(mse_list)</span>
<span id="cb9-27"><a href="#cb9-27" tabindex="-1"></a>std_mse <span class="ot">&lt;-</span> <span class="fu">sd</span>(mse_list)</span>
<span id="cb9-28"><a href="#cb9-28" tabindex="-1"></a></span>
<span id="cb9-29"><a href="#cb9-29" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;Average Test MSE (Repeated Validation):&quot;</span>, <span class="fu">round</span>(avg_mse, <span class="dv">2</span>), <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span></code></pre></div>
<pre><code>## Average Test MSE (Repeated Validation): 161115.8</code></pre>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;Standard Deviation of Test MSE:&quot;</span>, <span class="fu">round</span>(std_mse, <span class="dv">2</span>), <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span></code></pre></div>
<pre><code>## Standard Deviation of Test MSE: 22080.47</code></pre>
<p>Repeated validation gives us average MSE of <code>161115.8</code> (in
grams), which might seems large but corresponds to <span class="math inline">\(\sqrt{161115.8} \approx 401.39\)</span> grams on
average.</p>
<p>Now we apply 10-fold cross-validation in a similar way and compare
the results from these two approaches.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="co"># 10-fold cross-validation</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co"># Set seed for reproducibility</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a><span class="co"># Set amount of folds</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(penguins)</span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="co"># Define folds, similarly as in Exercise 1</span></span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a>folds <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>k, <span class="at">length.out =</span> n))</span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a><span class="co"># We will store mse for each fold in mse_fold object</span></span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a>mse_fold <span class="ot">&lt;-</span> <span class="fu">numeric</span>(k)</span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>k) {</span>
<span id="cb13-17"><a href="#cb13-17" tabindex="-1"></a>  <span class="co"># Pick fold for testing</span></span>
<span id="cb13-18"><a href="#cb13-18" tabindex="-1"></a>  test_idx <span class="ot">&lt;-</span> <span class="fu">which</span>(folds <span class="sc">==</span> i)</span>
<span id="cb13-19"><a href="#cb13-19" tabindex="-1"></a>  <span class="co"># Remaining data serves as training data</span></span>
<span id="cb13-20"><a href="#cb13-20" tabindex="-1"></a>  train <span class="ot">&lt;-</span> penguins[<span class="sc">-</span>test_idx, ]</span>
<span id="cb13-21"><a href="#cb13-21" tabindex="-1"></a>  test <span class="ot">&lt;-</span> penguins[test_idx, ]</span>
<span id="cb13-22"><a href="#cb13-22" tabindex="-1"></a></span>
<span id="cb13-23"><a href="#cb13-23" tabindex="-1"></a>  <span class="co"># Fit model on train data</span></span>
<span id="cb13-24"><a href="#cb13-24" tabindex="-1"></a>  model <span class="ot">&lt;-</span> <span class="fu">lm</span>(body_mass_g <span class="sc">~</span> bill_length_mm <span class="sc">+</span> flipper_length_mm, <span class="at">data =</span> train)</span>
<span id="cb13-25"><a href="#cb13-25" tabindex="-1"></a>  <span class="co"># Predict observations from test set</span></span>
<span id="cb13-26"><a href="#cb13-26" tabindex="-1"></a>  predictions <span class="ot">&lt;-</span> <span class="fu">predict</span>(model, test)</span>
<span id="cb13-27"><a href="#cb13-27" tabindex="-1"></a>  <span class="co"># Calculate MSE for test data</span></span>
<span id="cb13-28"><a href="#cb13-28" tabindex="-1"></a>  mse_fold[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>((test<span class="sc">$</span>body_mass_g <span class="sc">-</span> predictions)<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb13-29"><a href="#cb13-29" tabindex="-1"></a>}</span>
<span id="cb13-30"><a href="#cb13-30" tabindex="-1"></a></span>
<span id="cb13-31"><a href="#cb13-31" tabindex="-1"></a><span class="co"># Report average MSE and standard deviation</span></span>
<span id="cb13-32"><a href="#cb13-32" tabindex="-1"></a>cv_mse_mean <span class="ot">&lt;-</span> <span class="fu">mean</span>(mse_fold)</span>
<span id="cb13-33"><a href="#cb13-33" tabindex="-1"></a>cv_mse_std <span class="ot">&lt;-</span> <span class="fu">sd</span>(mse_fold)</span>
<span id="cb13-34"><a href="#cb13-34" tabindex="-1"></a></span>
<span id="cb13-35"><a href="#cb13-35" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;10-Fold CV MSE:&quot;</span>, <span class="fu">round</span>(cv_mse_mean, <span class="dv">2</span>), <span class="st">&quot;±&quot;</span>, <span class="fu">round</span>(cv_mse_std, <span class="dv">2</span>), <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span></code></pre></div>
<pre><code>## 10-Fold CV MSE: 156138.3 ± 30326.53</code></pre>
<p>10-fold cross-validation produces average MSE of
<code>156888.5</code> which is lower than what we obtained with repeated
validation. However, this improvement is accompanied by a notable
increase in the standard deviation, indicating greater variability in
performance across folds.</p>
<p>We now proceed to apply the bootstrap method to estimate the standard
errors of the model coefficients.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="co"># Set seed for reproducibility</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">103</span>)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co"># Bootstrap will be performed using boot function from boot package.</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="co"># boot(data, statistic, R, ...)</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a><span class="co"># data      - the dataset to resample from; can be a vector, matrix, or data frame.</span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a><span class="co"># statistic - a user-defined function of the form function(data, indices) that returns the statistic of interest.</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a><span class="co">#             &#39;data&#39; is the original dataset; &#39;indices&#39; is a vector of resampled indices.</span></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a><span class="co"># R         - number of bootstrap replicates to perform.</span></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a><span class="co"># ...       - additional arguments passed to the statistic function (if needed).</span></span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a><span class="co"># Returns an object of class &quot;boot&quot;, containing:</span></span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a><span class="co">#   - t0   : the observed value of the statistic on the original data</span></span>
<span id="cb15-16"><a href="#cb15-16" tabindex="-1"></a><span class="co">#   - t    : a vector of the bootstrap replications of the statistic</span></span>
<span id="cb15-17"><a href="#cb15-17" tabindex="-1"></a><span class="co">#   - R    : number of bootstrap replicates used</span></span>
<span id="cb15-18"><a href="#cb15-18" tabindex="-1"></a><span class="co">#   - data : the original dataset</span></span>
<span id="cb15-19"><a href="#cb15-19" tabindex="-1"></a><span class="co">#   - call : the original call to boot()</span></span>
<span id="cb15-20"><a href="#cb15-20" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" tabindex="-1"></a></span>
<span id="cb15-22"><a href="#cb15-22" tabindex="-1"></a><span class="co"># We define function boot_fn which will output</span></span>
<span id="cb15-23"><a href="#cb15-23" tabindex="-1"></a><span class="co"># coefficients of linear model. We will pass it as &#39;statistic&#39; argument</span></span>
<span id="cb15-24"><a href="#cb15-24" tabindex="-1"></a>boot_fn <span class="ot">&lt;-</span> <span class="cf">function</span>(data, indices) {</span>
<span id="cb15-25"><a href="#cb15-25" tabindex="-1"></a>  d <span class="ot">&lt;-</span> data[indices, ]</span>
<span id="cb15-26"><a href="#cb15-26" tabindex="-1"></a>  <span class="fu">coef</span>(<span class="fu">lm</span>(body_mass_g <span class="sc">~</span> bill_length_mm <span class="sc">+</span> flipper_length_mm, <span class="at">data =</span> d))</span>
<span id="cb15-27"><a href="#cb15-27" tabindex="-1"></a>}</span>
<span id="cb15-28"><a href="#cb15-28" tabindex="-1"></a></span>
<span id="cb15-29"><a href="#cb15-29" tabindex="-1"></a></span>
<span id="cb15-30"><a href="#cb15-30" tabindex="-1"></a><span class="co"># We perform 1000 bootstrap replications and estimate standard deviations</span></span>
<span id="cb15-31"><a href="#cb15-31" tabindex="-1"></a>boot_out <span class="ot">&lt;-</span> <span class="fu">boot</span>(<span class="at">data =</span> penguins, <span class="at">statistic =</span> boot_fn, <span class="at">R =</span> <span class="dv">1000</span>)</span>
<span id="cb15-32"><a href="#cb15-32" tabindex="-1"></a>bootstrap_se <span class="ot">&lt;-</span> <span class="fu">apply</span>(boot_out<span class="sc">$</span>t, <span class="dv">2</span>, sd)</span>
<span id="cb15-33"><a href="#cb15-33" tabindex="-1"></a></span>
<span id="cb15-34"><a href="#cb15-34" tabindex="-1"></a><span class="co"># We print all results in a single table</span></span>
<span id="cb15-35"><a href="#cb15-35" tabindex="-1"></a>summary_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb15-36"><a href="#cb15-36" tabindex="-1"></a>  <span class="at">Coefficient =</span> <span class="fu">names</span>(<span class="fu">coef</span>(model_full)),</span>
<span id="cb15-37"><a href="#cb15-37" tabindex="-1"></a>  <span class="at">OLS_Std_Err =</span> <span class="fu">summary</span>(model_full)<span class="sc">$</span>coefficients[, <span class="st">&quot;Std. Error&quot;</span>],</span>
<span id="cb15-38"><a href="#cb15-38" tabindex="-1"></a>  <span class="at">Bootstrap_Std_Err =</span> bootstrap_se</span>
<span id="cb15-39"><a href="#cb15-39" tabindex="-1"></a>)</span>
<span id="cb15-40"><a href="#cb15-40" tabindex="-1"></a></span>
<span id="cb15-41"><a href="#cb15-41" tabindex="-1"></a><span class="fu">print</span>(summary_df)</span></code></pre></div>
<pre><code>##                         Coefficient OLS_Std_Err Bootstrap_Std_Err
## (Intercept)             (Intercept)  307.959128        287.679797
## bill_length_mm       bill_length_mm    5.179831          4.747489
## flipper_length_mm flipper_length_mm    2.011115          1.826204</code></pre>
<p>The standard error estimates obtained via bootstrap are generally
similar to those derived from the OLS model using asymptotic theory.
Interestingly, all bootstrap estimates are slightly lower. There is no
clear reason to favor one method over the other in terms of accuracy, as
neither can be definitively considered closer to the true standard
errors. However, the bootstrap approach has the advantage of being more
robust to violations of model assumptions, making it a valuable
complement to traditional methods.</p>
</div>
</div>
<div id="exercise-3" class="section level1">
<h1>Exercise 3</h1>
<p>The <code>boot</code> package in R can be used to apply the bootstrap
to a wide range of statistics. In this exercise, you will simulate data
from a known distribution and use the bootstrap to estimate the standard
error and bias of the sample median.</p>
<ol style="list-style-type: decimal">
<li>Generate a population of 100000 observations from a standard normal
distribution using:</li>
</ol>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>population <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">100000</span>)</span></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li><p>Use Monte Carlo simulation to estimate the true sampling
distribution of the sample median:</p>
<ul>
<li><p>Repeat the following 10000 times:</p>
<ul>
<li><p>Draw a random sample of size 100 from the population.</p></li>
<li><p>Compute the sample median.</p></li>
</ul></li>
<li><p>Store the results and calculate the standard deviation and bias
(relative to the true median).</p></li>
</ul></li>
<li><p>Draw a single random sample of size 100 from the population and
compute the sample median.</p></li>
<li><p>Apply the bootstrap (1000 replications) to this single sample to
estimate the standard error and bias of the median using:</p></li>
</ol>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="fu">boot</span>(<span class="at">data =</span> sample, <span class="at">statistic =</span> <span class="cf">function</span>(data, i) <span class="fu">median</span>(data[i]), <span class="at">R =</span> <span class="dv">1000</span>)</span></code></pre></div>
<ol start="5" style="list-style-type: decimal">
<li><p>Compare the bootstrap-estimated standard error and bias to the
true values obtained from the Monte Carlo simulation. How close are
they?</p></li>
<li><p>Repeat <strong>Exercise 3.3</strong> to <strong>Exercise
3.5</strong> using the interquartile range (IQR) instead of the
median.</p></li>
</ol>
<button onclick="toggleSolution(this)">
Show/Hide Solution
</button>
<div class="solution" style="display:none;">
<p>We generate 100 000 observations from the standard normal
distribution <span class="math inline">\(\mathcal{N}(0,1)\)</span>,
which will serve as our approximation of the population.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="fu">library</span>(boot)</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="co"># Generate population</span></span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a><span class="co"># Seed is set for reproducibility </span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">103</span>)</span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>population <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">100000</span>)</span></code></pre></div>
<p>We want to approximate the sampling distribution of the median based
on samples of size <span class="math inline">\(100\)</span>. We
repeatedly draw samples of 100 observations from the generated
population and compute the median for each sample.</p>
<p>The resulting distribution of medians allows us to estimate both the
standard deviation (as a measure of variability) and the bias of the
sample median as an estimator.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="co"># We now wish to approximate distribution of median, we will</span></span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="co"># generate 10.000 samples of size 100 and for each sample </span></span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a><span class="co"># we will calculate the median</span></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>n_sim <span class="ot">&lt;-</span> <span class="dv">10000</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>sample_size <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a>medians_mc <span class="ot">&lt;-</span> <span class="fu">replicate</span>(n_sim, {</span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a>  sample <span class="ot">&lt;-</span> <span class="fu">sample</span>(population, sample_size)</span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a>  <span class="fu">median</span>(sample)</span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a>})</span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a><span class="co"># We can report standard deviation of median</span></span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a>mc_std_median <span class="ot">&lt;-</span> <span class="fu">sd</span>(medians_mc)</span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a><span class="co"># and bias of estimation (note that real median here is mean(population))</span></span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a>mc_bias_median <span class="ot">&lt;-</span> <span class="fu">mean</span>(medians_mc) <span class="sc">-</span> <span class="fu">mean</span>(population)</span></code></pre></div>
<p>We now examine the performance of the bootstrap method by generating
a single sample from the dataset and applying the bootstrap procedure
based solely on this sample.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="co"># Draw single sample and compute sample median</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>sample <span class="ot">&lt;-</span> <span class="fu">sample</span>(population, sample_size)</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>sample_median <span class="ot">&lt;-</span> <span class="fu">median</span>(sample)</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>sample_median</span></code></pre></div>
<pre><code>## [1] -0.02536607</code></pre>
<p>The sample median is equal <span class="math inline">\(-0.02536607\)</span>.</p>
<p>We apply the <code>boot()</code> function from the boot package to
estimate the standard error and bias of the sample median. The function
<code>boot_median_fn</code> computes the median on each resampled
dataset. With <span class="math inline">\(1000\)</span> bootstrap
replications, we extract the standard error as the standard deviation of
the bootstrap distribution and compute the bias as the difference
between the mean bootstrap estimate and the original sample median.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="co"># Define the statistic function for boot()</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>boot_median_fn <span class="ot">&lt;-</span> <span class="cf">function</span>(data, indices) {</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>  <span class="fu">median</span>(data[indices])</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>}</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a><span class="co"># Perform bootstrap on the single sample using 1000 replications</span></span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>boot_out <span class="ot">&lt;-</span> <span class="fu">boot</span>(<span class="at">data =</span> sample, <span class="at">statistic =</span> boot_median_fn, <span class="at">R =</span> <span class="dv">1000</span>)</span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a><span class="co"># Extract the original sample median (computed by boot)</span></span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a>sample_median <span class="ot">&lt;-</span> boot_out<span class="sc">$</span>t0</span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" tabindex="-1"></a><span class="co"># Calculate standard error as the standard deviation of the bootstrap estimates</span></span>
<span id="cb23-13"><a href="#cb23-13" tabindex="-1"></a>boot_std_median <span class="ot">&lt;-</span> <span class="fu">sd</span>(boot_out<span class="sc">$</span>t)</span>
<span id="cb23-14"><a href="#cb23-14" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" tabindex="-1"></a><span class="co"># Calculate bias as the difference between the average bootstrap estimate and the sample median</span></span>
<span id="cb23-16"><a href="#cb23-16" tabindex="-1"></a>boot_bias_median <span class="ot">&lt;-</span> <span class="fu">mean</span>(boot_out<span class="sc">$</span>t) <span class="sc">-</span> sample_median</span></code></pre></div>
<p>We display and compare the results obtained from the Monte Carlo
simulation and the bootstrap procedure.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="co"># We store results in data.frame and </span></span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a><span class="co"># compare Monte Carlo to Bootstrap </span></span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>median_results <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>  <span class="at">Method =</span> <span class="fu">c</span>(<span class="st">&quot;Monte Carlo&quot;</span>, <span class="st">&quot;Bootstrap&quot;</span>),</span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a>  <span class="at">SE =</span> <span class="fu">c</span>(mc_std_median, boot_std_median),</span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a>  <span class="at">Bias =</span> <span class="fu">c</span>(mc_bias_median, boot_bias_median)</span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a>)</span>
<span id="cb24-8"><a href="#cb24-8" tabindex="-1"></a>median_results</span></code></pre></div>
<pre><code>##        Method        SE         Bias
## 1 Monte Carlo 0.1241811 0.0002378376
## 2   Bootstrap 0.1021768 0.0028326788</code></pre>
<p>The results obtained using the Monte Carlo method can be treated as
benchmark estimates, as they are based on repeated sampling from the
full population. The bootstrap estimates, which rely on just a single
sample, are quite close to these reference values. The difference in
standard error is approximately <span class="math inline">\(0.02\)</span>, and the bias differs by about <span class="math inline">\(0.0026\)</span>.</p>
<p>We will now repeat entire process for IQR.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="co"># IQR</span></span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a><span class="co"># Number of bootstrap replications</span></span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a>n_boot <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a><span class="co"># Monte Carlo</span></span>
<span id="cb26-7"><a href="#cb26-7" tabindex="-1"></a>iqrs_mc <span class="ot">&lt;-</span> <span class="fu">replicate</span>(n_sim, {</span>
<span id="cb26-8"><a href="#cb26-8" tabindex="-1"></a>  s <span class="ot">&lt;-</span> <span class="fu">sample</span>(population, sample_size)</span>
<span id="cb26-9"><a href="#cb26-9" tabindex="-1"></a>  <span class="fu">IQR</span>(s)</span>
<span id="cb26-10"><a href="#cb26-10" tabindex="-1"></a>})</span>
<span id="cb26-11"><a href="#cb26-11" tabindex="-1"></a>mc_std_iqr <span class="ot">&lt;-</span> <span class="fu">sd</span>(iqrs_mc)</span>
<span id="cb26-12"><a href="#cb26-12" tabindex="-1"></a>mc_bias_iqr <span class="ot">&lt;-</span> <span class="fu">mean</span>(iqrs_mc) <span class="sc">-</span> <span class="fu">IQR</span>(population)</span>
<span id="cb26-13"><a href="#cb26-13" tabindex="-1"></a></span>
<span id="cb26-14"><a href="#cb26-14" tabindex="-1"></a><span class="co"># Bootstrap</span></span>
<span id="cb26-15"><a href="#cb26-15" tabindex="-1"></a>sample_iqr <span class="ot">&lt;-</span> <span class="fu">IQR</span>(sample)</span>
<span id="cb26-16"><a href="#cb26-16" tabindex="-1"></a>boot_iqrs <span class="ot">&lt;-</span> <span class="fu">replicate</span>(n_boot, {</span>
<span id="cb26-17"><a href="#cb26-17" tabindex="-1"></a>  <span class="fu">IQR</span>(<span class="fu">sample</span>(sample, sample_size, <span class="at">replace =</span> <span class="cn">TRUE</span>))</span>
<span id="cb26-18"><a href="#cb26-18" tabindex="-1"></a>})</span>
<span id="cb26-19"><a href="#cb26-19" tabindex="-1"></a>boot_std_iqr <span class="ot">&lt;-</span> <span class="fu">sd</span>(boot_iqrs)</span>
<span id="cb26-20"><a href="#cb26-20" tabindex="-1"></a>boot_bias_iqr <span class="ot">&lt;-</span> <span class="fu">mean</span>(boot_iqrs) <span class="sc">-</span> sample_iqr</span>
<span id="cb26-21"><a href="#cb26-21" tabindex="-1"></a></span>
<span id="cb26-22"><a href="#cb26-22" tabindex="-1"></a><span class="co"># Results table</span></span>
<span id="cb26-23"><a href="#cb26-23" tabindex="-1"></a>iqr_results <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb26-24"><a href="#cb26-24" tabindex="-1"></a>  <span class="at">Method =</span> <span class="fu">c</span>(<span class="st">&quot;Monte Carlo&quot;</span>, <span class="st">&quot;Bootstrap&quot;</span>),</span>
<span id="cb26-25"><a href="#cb26-25" tabindex="-1"></a>  <span class="at">SE =</span> <span class="fu">c</span>(mc_std_iqr, boot_std_iqr),</span>
<span id="cb26-26"><a href="#cb26-26" tabindex="-1"></a>  <span class="at">Bias =</span> <span class="fu">c</span>(mc_bias_iqr, boot_bias_iqr)</span>
<span id="cb26-27"><a href="#cb26-27" tabindex="-1"></a>)</span>
<span id="cb26-28"><a href="#cb26-28" tabindex="-1"></a>iqr_results</span></code></pre></div>
<pre><code>##        Method        SE        Bias
## 1 Monte Carlo 0.1545626 -0.02008485
## 2   Bootstrap 0.2134852 -0.06952994</code></pre>
<p>The Standard Error of the IQR estimated using the bootstrap method is
close to the value obtained via Monte Carlo simulation. While the bias
estimated by the bootstrap is slightly larger, the overall difference
(approximately <span class="math inline">\(0.04\)</span>) remains
relatively small, demonstrating that bootstrap can still provide useful
insights, especially when access to the full population is limited.</p>
</div>
</div>
<div id="exercise-4" class="section level1">
<h1>Exercise 4</h1>
<p>In this exercise, you will explore the stability of model selection
using repeated cross-validation. The goal is to examine how often
different linear models are selected as the best based on
cross-validated mean squared error.</p>
<ol style="list-style-type: decimal">
<li>Use the following code to load penguins dataset:</li>
</ol>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>url <span class="ot">&lt;-</span> <span class="st">&quot;https://raw.githubusercontent.com/allisonhorst/palmerpenguins/master/inst/extdata/penguins.csv&quot;</span></span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>penguins <span class="ot">&lt;-</span> <span class="fu">na.omit</span>(<span class="fu">read.csv</span>(url))</span></code></pre></div>
<p>2.Define a set of 4 candidate models to predict
<code>body_mass_g</code>:</p>
<pre><code>- Model 1: `body_mass_g` ~ `flipper_length_mm`

- Model 2: `body_mass_g` ~ `flipper_length_mm` + `bill_length_mm`

- Model 3: `body_mass_g` ~ `flipper_length_mm` + `bill_depth_mm`

- Model 4: `body_mass_g` ~ `flipper_length_mm` + `bill_length_mm` + `bill_depth_mm`</code></pre>
<ol start="3" style="list-style-type: decimal">
<li><p>Perform the following steps 100 times:</p>
<ul>
<li><p>Randomly split the data into 10 folds.</p></li>
<li><p>Use 10-fold cross-validation to estimate the test MSE of each
model.</p></li>
<li><p>Record which model has the lowest estimated test MSE.</p></li>
</ul></li>
<li><p>After all repetitions, report the selection frequency of each
model.</p></li>
<li><p>Visualize the model selection frequencies as a bar plot.</p></li>
</ol>
<button onclick="toggleSolution(this)">
Show/Hide Solution
</button>
<div class="solution" style="display:none;">
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="co"># Load required libraries</span></span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a><span class="fu">library</span>(purrr)</span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a><span class="fu">library</span>(broom)</span></code></pre></div>
<p>We load the <code>penguins</code> dataset using the URL provided in
the exercise since the version in the <code>palmerpenguins</code>
package omits several useful variables. After loading the data, we
remove any rows with missing values to ensure a clean dataset for
modeling. To keep the code organized and readable, we define a list
containing four predefined models: <code>Model 1</code>,
<code>Model 2</code>, <code>Model 3</code>, <code>Model 4</code>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="co"># Load and clean data</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>url <span class="ot">&lt;-</span> <span class="st">&quot;https://raw.githubusercontent.com/allisonhorst/palmerpenguins/master/inst/extdata/penguins.csv&quot;</span></span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>penguins <span class="ot">&lt;-</span> <span class="fu">na.omit</span>(<span class="fu">read.csv</span>(url))</span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a><span class="co"># Seed is set for reproducibility </span></span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">103</span>)</span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a><span class="co"># For convenience we store all potential models in form of list</span></span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a>models <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb31-10"><a href="#cb31-10" tabindex="-1"></a>  <span class="st">&quot;Model 1&quot;</span> <span class="ot">=</span> body_mass_g <span class="sc">~</span> flipper_length_mm,</span>
<span id="cb31-11"><a href="#cb31-11" tabindex="-1"></a>  <span class="st">&quot;Model 2&quot;</span> <span class="ot">=</span> body_mass_g <span class="sc">~</span> flipper_length_mm <span class="sc">+</span> bill_length_mm,</span>
<span id="cb31-12"><a href="#cb31-12" tabindex="-1"></a>  <span class="st">&quot;Model 3&quot;</span> <span class="ot">=</span> body_mass_g <span class="sc">~</span> flipper_length_mm <span class="sc">+</span> bill_depth_mm,</span>
<span id="cb31-13"><a href="#cb31-13" tabindex="-1"></a>  <span class="st">&quot;Model 4&quot;</span> <span class="ot">=</span> body_mass_g <span class="sc">~</span> flipper_length_mm <span class="sc">+</span> bill_length_mm <span class="sc">+</span> bill_depth_mm</span>
<span id="cb31-14"><a href="#cb31-14" tabindex="-1"></a>)</span>
<span id="cb31-15"><a href="#cb31-15" tabindex="-1"></a></span>
<span id="cb31-16"><a href="#cb31-16" tabindex="-1"></a><span class="co"># We will store number of times model was &#39;best&#39;, according to average MSE, in this variable:</span></span>
<span id="cb31-17"><a href="#cb31-17" tabindex="-1"></a>selection_counts <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">rep</span>(<span class="dv">0</span>, <span class="fu">length</span>(models)), <span class="fu">names</span>(models))</span></code></pre></div>
<p>We perform 10-fold cross-validation repeated <span class="math inline">\(100\)</span> times. In each repetition, the
dataset is randomly partitioned into <span class="math inline">\(10\)</span> folds. For each model, we compute the
average test MSE across all <span class="math inline">\(10\)</span>
folds. This process is repeated <span class="math inline">\(100\)</span>
times and in each iteration we record which model achieved the lowest
average MSE. This will allow us to see which of predictors are “strong”,
i.e. which are usually chosen.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="co"># Repeated 10-fold cross-validation</span></span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>reps <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(penguins)</span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a><span class="co"># Loop over iteration first</span></span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>reps) {</span>
<span id="cb32-8"><a href="#cb32-8" tabindex="-1"></a>  <span class="co"># For each iteration we select different folds split randomly</span></span>
<span id="cb32-9"><a href="#cb32-9" tabindex="-1"></a>  folds <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>k, <span class="at">length.out =</span> n))</span>
<span id="cb32-10"><a href="#cb32-10" tabindex="-1"></a></span>
<span id="cb32-11"><a href="#cb32-11" tabindex="-1"></a>  mse_list <span class="ot">&lt;-</span> <span class="fu">sapply</span>(models, <span class="cf">function</span>(formula) {</span>
<span id="cb32-12"><a href="#cb32-12" tabindex="-1"></a>    mse_fold <span class="ot">&lt;-</span> <span class="fu">numeric</span>(k)</span>
<span id="cb32-13"><a href="#cb32-13" tabindex="-1"></a>    <span class="co"># There we loop over folds and obtain test MSE</span></span>
<span id="cb32-14"><a href="#cb32-14" tabindex="-1"></a>    <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>k) {</span>
<span id="cb32-15"><a href="#cb32-15" tabindex="-1"></a>      test_idx <span class="ot">&lt;-</span> <span class="fu">which</span>(folds <span class="sc">==</span> j)</span>
<span id="cb32-16"><a href="#cb32-16" tabindex="-1"></a>      train_data <span class="ot">&lt;-</span> penguins[<span class="sc">-</span>test_idx, ]</span>
<span id="cb32-17"><a href="#cb32-17" tabindex="-1"></a>      test_data <span class="ot">&lt;-</span> penguins[test_idx, ]</span>
<span id="cb32-18"><a href="#cb32-18" tabindex="-1"></a>      model <span class="ot">&lt;-</span> <span class="fu">lm</span>(formula, <span class="at">data =</span> train_data)</span>
<span id="cb32-19"><a href="#cb32-19" tabindex="-1"></a>      preds <span class="ot">&lt;-</span> <span class="fu">predict</span>(model, <span class="at">newdata =</span> test_data)</span>
<span id="cb32-20"><a href="#cb32-20" tabindex="-1"></a>      mse_fold[j] <span class="ot">&lt;-</span> <span class="fu">mean</span>((test_data<span class="sc">$</span>body_mass_g <span class="sc">-</span> preds)<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb32-21"><a href="#cb32-21" tabindex="-1"></a>    }</span>
<span id="cb32-22"><a href="#cb32-22" tabindex="-1"></a>    <span class="fu">mean</span>(mse_fold)</span>
<span id="cb32-23"><a href="#cb32-23" tabindex="-1"></a>  })</span>
<span id="cb32-24"><a href="#cb32-24" tabindex="-1"></a></span>
<span id="cb32-25"><a href="#cb32-25" tabindex="-1"></a>  <span class="co"># Best model here is the one with lowest average MSE</span></span>
<span id="cb32-26"><a href="#cb32-26" tabindex="-1"></a>  best_model <span class="ot">&lt;-</span> <span class="fu">names</span>(<span class="fu">which.min</span>(mse_list))</span>
<span id="cb32-27"><a href="#cb32-27" tabindex="-1"></a>  <span class="co"># We add 1 selection to the selected model</span></span>
<span id="cb32-28"><a href="#cb32-28" tabindex="-1"></a>  selection_counts[best_model] <span class="ot">&lt;-</span> selection_counts[best_model] <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb32-29"><a href="#cb32-29" tabindex="-1"></a>}</span></code></pre></div>
<p>We display how many times each model was selected across the <span class="math inline">\(100\)</span> repetitions.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="co"># Show selection frequencies</span></span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>selection_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>  <span class="at">Model =</span> <span class="fu">names</span>(selection_counts),</span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a>  <span class="at">Frequency =</span> <span class="fu">as.numeric</span>(selection_counts)</span>
<span id="cb33-5"><a href="#cb33-5" tabindex="-1"></a>)</span>
<span id="cb33-6"><a href="#cb33-6" tabindex="-1"></a>selection_df</span></code></pre></div>
<pre><code>##     Model Frequency
## 1 Model 1        20
## 2 Model 2         2
## 3 Model 3        78
## 4 Model 4         0</code></pre>
<p>From the results, we observe that <code>Model 1</code> was selected
<span class="math inline">\(20\)</span> times, <code>Model 2</code> only
<span class="math inline">\(2\)</span> times, <code>Model 3</code> was
chosen most often (<span class="math inline">\(78\)</span> times) and
<code>Model 4</code> was never selected.</p>
<p>To better visualize these outcomes, we plot the selection
frequencies.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a><span class="co"># Plot selection frequencies</span></span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a><span class="fu">ggplot</span>(selection_df, <span class="fu">aes</span>(<span class="at">x =</span> Model, <span class="at">y =</span> Frequency)) <span class="sc">+</span></span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">stat =</span> <span class="st">&quot;identity&quot;</span>, <span class="at">fill =</span> <span class="st">&quot;#1f77b4&quot;</span>) <span class="sc">+</span></span>
<span id="cb35-4"><a href="#cb35-4" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">&quot;Model Selection Frequencies over 100 Repetitions&quot;</span>,</span>
<span id="cb35-5"><a href="#cb35-5" tabindex="-1"></a>       <span class="at">x =</span> <span class="st">&quot;Model&quot;</span>, <span class="at">y =</span> <span class="st">&quot;Selection Frequency&quot;</span>) <span class="sc">+</span></span>
<span id="cb35-6"><a href="#cb35-6" tabindex="-1"></a>  <span class="fu">theme_classic</span>() <span class="sc">+</span></span>
<span id="cb35-7"><a href="#cb35-7" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>))</span></code></pre></div>
<p><img role="img" src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
<p>Most frequently, <code>Model 3</code> is selected as the
best-performing model based on average test MSE. This suggests that
including <code>bill_depth_mm</code> alongside
<code>flipper_length_mm</code> provides strong predictive power.</p>
<p>In contrast, <code>Model 4</code> is never selected, indicating that
adding <code>bill_length_mm</code> to a model already containing
<code>flipper_length_mm</code> and <code>bill_depth_mm</code> does not
lead to meaningful improvement. Similarly, <code>Model 2</code> - which
adds <code>bill_length_mm</code> but not <code>bill_depth_mm</code> - is
selected only rarely. This pattern suggests that
<code>bill_length_mm</code> contributes little to predictive accuracy in
the presence of the other variables.</p>
</div>
</div>
</div>
<div id="py1" class="tab-content">
<div id="exercise-1-1" class="section level1">
<h1>Exercise 1</h1>
<p>The <code>diamonds</code> dataset contains prices and attributes of
over <span class="math inline">\(50,000\)</span> diamonds, including
characteristics such as carat size, cut, color, and clarity. In Python,
this dataset is accessible using the <code>seaborn</code> library. To
load it, write <code>seaborn.load_dataset(&quot;diamonds&quot;)</code>.</p>
<p>The dataset includes the following variables:</p>
<ul>
<li><p><strong>price</strong>: price (US dollars),</p></li>
<li><p><strong>carat</strong>: weight of the diamond,</p></li>
<li><p><strong>cut</strong>: quality of the cut (<code>Fair</code>,
<code>Good</code>, <code>Very Good</code>, <code>Premium</code>,
<code>Ideal</code>),</p></li>
<li><p><strong>color</strong>: diamond color, from <code>J</code>
(worst) to <code>D</code> (best),</p></li>
<li><p><strong>clarity</strong>: measurement of how clear the diamond
is,</p></li>
<li><p><strong>x</strong>, <strong>y</strong>, <strong>z</strong>:
physical dimensions - <code>length</code>, <code>width</code>,
<code>depth</code> (mm).</p></li>
</ul>
<ol style="list-style-type: decimal">
<li><p>Using only complete cases, fit polynomial regression models of
degrees 1 through 5 to predict <code>price</code> based on
<code>carat</code> (e.g., using <code>PolynomialFeatures</code> from
<code>sklearn.preprocessing</code>).</p></li>
<li><p>Use 10-fold cross-validation (e.g., with
<code>cross_val_score</code> from <code>sklearn.model_selection</code>)
to estimate the test MSE for each polynomial degree.</p></li>
<li><p>Create a plot showing polynomial degree on the x-axis and the
corresponding cross-validated MSE on the y-axis.</p></li>
<li><p>Which polynomial degree gives the lowest estimated test error?
What does this suggest about the relationship between <code>carat</code>
and <code>price</code>?</p></li>
</ol>
<button onclick="toggleSolution(this)">
Show/Hide Solution
</button>
<div class="solution" style="display:none;">
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="co"># Import required libraries</span></span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb36-5"><a href="#cb36-5" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt<span class="op">;</span></span>
<span id="cb36-6"><a href="#cb36-6" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> PolynomialFeatures</span>
<span id="cb36-8"><a href="#cb36-8" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LinearRegression</span>
<span id="cb36-9"><a href="#cb36-9" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> cross_val_score</span>
<span id="cb36-10"><a href="#cb36-10" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> mean_squared_error</span></code></pre></div>
<p>We begin by loading <code>diamonds</code> dataset, which is available
in the <code>seaborn</code> package. Using <code>dropna()</code> we can
exclude all observations with at least one missing value.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a><span class="co"># set seed for reproducibility</span></span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a>np.random.seed(<span class="dv">103</span>) </span>
<span id="cb37-3"><a href="#cb37-3" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" tabindex="-1"></a><span class="co"># Load diamonds dataset and drop missing values</span></span>
<span id="cb37-5"><a href="#cb37-5" tabindex="-1"></a>diamonds <span class="op">=</span> sns.load_dataset(<span class="st">&quot;diamonds&quot;</span>)</span>
<span id="cb37-6"><a href="#cb37-6" tabindex="-1"></a>diamonds <span class="op">=</span> diamonds.dropna()</span>
<span id="cb37-7"><a href="#cb37-7" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" tabindex="-1"></a><span class="co"># Keep only the relevant variables</span></span>
<span id="cb37-9"><a href="#cb37-9" tabindex="-1"></a>X <span class="op">=</span> diamonds[[<span class="st">&#39;carat&#39;</span>]]</span>
<span id="cb37-10"><a href="#cb37-10" tabindex="-1"></a>y <span class="op">=</span> diamonds[<span class="st">&#39;price&#39;</span>]</span></code></pre></div>
<p>To fit linear regression models of
<code>price</code>~<code>carat</code>^d, for <span class="math inline">\(d=1,2,3,4,5\)</span> we use
<code>PolynomialFeatures()</code> function (we can also create new
variables corresponding to higher powers of <code>carat</code> and use
them).</p>
<p>For each degree, 10-fold cross validation is done. This is done using
<code>cross_val_score</code>function which is available in
<code>sklearn</code> package.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="co"># Define powers to loop through, you are free to include higher powers</span></span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a>degrees <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a><span class="co"># Prepare to store results</span></span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a>mse_scores <span class="op">=</span> []</span>
<span id="cb38-5"><a href="#cb38-5" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" tabindex="-1"></a><span class="co"># Loop over polynomial degrees</span></span>
<span id="cb38-7"><a href="#cb38-7" tabindex="-1"></a><span class="cf">for</span> d <span class="kw">in</span> degrees:</span>
<span id="cb38-8"><a href="#cb38-8" tabindex="-1"></a>    <span class="co"># For every degree d we introduce carat^d variable</span></span>
<span id="cb38-9"><a href="#cb38-9" tabindex="-1"></a>    poly <span class="op">=</span> PolynomialFeatures(degree<span class="op">=</span>d)</span>
<span id="cb38-10"><a href="#cb38-10" tabindex="-1"></a>    X_poly <span class="op">=</span> poly.fit_transform(X)</span>
<span id="cb38-11"><a href="#cb38-11" tabindex="-1"></a>    <span class="co"># This variable is used to train linear regression model. Note </span></span>
<span id="cb38-12"><a href="#cb38-12" tabindex="-1"></a>    <span class="co"># that this implementation does not require you to </span></span>
<span id="cb38-13"><a href="#cb38-13" tabindex="-1"></a>    <span class="co"># create train/test sets yourself</span></span>
<span id="cb38-14"><a href="#cb38-14" tabindex="-1"></a>    model <span class="op">=</span> LinearRegression()</span>
<span id="cb38-15"><a href="#cb38-15" tabindex="-1"></a>    scores <span class="op">=</span> cross_val_score(model, X_poly, y, scoring<span class="op">=</span><span class="st">&#39;neg_mean_squared_error&#39;</span>, cv<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb38-16"><a href="#cb38-16" tabindex="-1"></a></span>
<span id="cb38-17"><a href="#cb38-17" tabindex="-1"></a>    <span class="co"># Store the mean MSE (convert negative to positive)</span></span>
<span id="cb38-18"><a href="#cb38-18" tabindex="-1"></a>    mse_scores.append(<span class="op">-</span>scores.mean())</span></code></pre></div>
<p>We visualize how the test error (measured by 10-fold cross-validated
MSE) changes with the degree of the polynomial used to model the
relationship between <code>price</code> and <code>carat</code>.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a><span class="co"># Results are plotted using pyplot package</span></span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a>plt.plot(degrees, mse_scores, marker<span class="op">=</span><span class="st">&#39;o&#39;</span>)<span class="op">;</span></span>
<span id="cb39-4"><a href="#cb39-4" tabindex="-1"></a>plt.xticks(ticks<span class="op">=</span>np.arange(<span class="bu">min</span>(degrees), <span class="bu">max</span>(degrees)<span class="op">+</span><span class="dv">1</span>, <span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb39-5"><a href="#cb39-5" tabindex="-1"></a>plt.xlabel(<span class="st">&quot;Polynomial Degree&quot;</span>)<span class="op">;</span></span>
<span id="cb39-6"><a href="#cb39-6" tabindex="-1"></a>plt.ylabel(<span class="st">&quot;10-fold Cross-Validated MSE&quot;</span>)<span class="op">;</span></span>
<span id="cb39-7"><a href="#cb39-7" tabindex="-1"></a>plt.title(<span class="st">&quot;Test Error vs. Polynomial Degree&quot;</span>)<span class="op">;</span></span>
<span id="cb39-8"><a href="#cb39-8" tabindex="-1"></a>plt.grid(<span class="va">True</span>)<span class="op">;</span></span>
<span id="cb39-9"><a href="#cb39-9" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb39-10"><a href="#cb39-10" tabindex="-1"></a>plt.show()<span class="op">;</span></span></code></pre></div>
<p><img role="img" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAwAAAAHgCAYAAAASWgolAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjMsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvZiW1igAAAAlwSFlzAAAOxAAADsQBlSsOGwAAeF9JREFUeJzt3Qd4FNXXBvA3vReSQAgt9JqErjQBkY50FFHs/i0INpAiIE2KiIqKCOqnKKCCFEF6EQQERVoSIIReQmghvbf9nnPDxiQECMkms+X9Pc+ws7O7s2c3QzJn7j33Wul0Oh2IiIiIiMgiWGsdABERERERlR0mAEREREREFoQJABERERGRBWECQERERERkQZgAEBERERFZECYAREREREQWhAkAEREREZEFYQJARERERGRBmAAQEREREVkQJgBERERERBaECQARERERkQVhAkBEREREZEGYABARERERWRAmAEREREREFoQJABERERGRBWECQERlwsrK6p5L9erVS/w+R44cweTJkxEdHV2k53fs2PGO8bz11luwdOfPn8/3ndjb26Nu3bp4++23ERMTc1/7kp+L7MPUyXH63HPP3ffrivr58x6TNjY2KFeuHJo0aYIRI0bg2LFjxYyaiOg/tnnWiYhKzb59+/Ld79+/Pxo3bqxOivQcHBwMkgBMmTIFQ4cOhZeXV5FeExQUhIULF9623c/Pr8TxmItx48ahT58+SEtLw19//YUPPvgAhw8fxo4dO8zipP5+rF69Gu7u7qX6HnmPyfj4eBw9ehTfffcdFixYgM8++wzDhg0r1fcnIvPGBICIykSrVq3y3ZeTfR8fn9u2a8HNza1YccjJcGFJy522F1VGRgZsbW2N6sS6Zs2aud9Rhw4dVIySvEkS0KxZM1iSpk2blvkx2bVrV9UCMGTIEHXbsmVLtZSVkh7TRGRc2AWIiIzGuXPn8NRTT6F8+fLqZEO6PcjV1rxOnjypWg8qVKgAR0dHVKtWDY899hgyMzOxaNEiPP/88+p5derUye1GId1YSkq6ZbRr1w6///67OgGU+ObPn4+dO3eq91i1ahX+97//qdh9fX3Va+QkecKECarLiHSdkVu5L9sLdrGRfY0ePRqVKlVS+46Njb0thqtXr6rE4PPPP7/tsdmzZ8POzg43btxQ9zdv3ow2bdrAw8MDrq6uqFevHqZOnQpD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NCJD2rp1K4KCguDi4qJur169qupOZP4JIkNxdnZGlSpV8i1CWgKk6xmRoSxZsgQNGjRQx1yzZs1Ui6b8TnNzc4OpsNKZUnsFERERERGVCFsAiIiIiIgsCBMAIiIiIiILwgSAiIiIiMiCMAEgIiIiIrIgTACIiIiIiCwIEwAiIiIiIgvCBICIiIiIyIIwASAiIiIisiBMAIiITJCVlZWaedKYzZgxA127di3y8ydPnox27dqVakxERMQEgIhIEx07doS9vT1cXV3h7u6OgIAA/N///R/MyXvvvYctW7YYbH+SINjY2OR+Z+XLl1ff45dffomMjAyDvQ8RkbljAkBEpJHRo0cjMTERMTExGDt2LF566SXs3LlT67CMWuvWrdV3Fh8fj3PnzmHkyJGYO3cuunTpUqpJQHp6eqntm4iorDEBICLSmFzVHjp0KLy9vXHw4EG1bf369WjevDk8PDxQt25dzJkzB9nZ2be9VrZVr14dP/zwQ77t8vymTZuq9UWLFqFKlSpYuHCheq7s87HHHlMn0XqXL1/G448/Dl9fX7UMHjwYkZGRuY8/99xzattrr72m4vTx8VEn3pcuXUK3bt3g5uaGhg0bYt++fXfs0iNX6qWlQ67eV6xYEU8//TSioqKK/b1JS0Dv3r2xZs0a9b6LFy/Ofeyff/5RrQMSq7+/PyZOnIjMzMzcx/fv34+WLVuquFu0aIFPPvlEdasqGLu8rlKlSmjSpInafuLECTz66KPqO6pcuTKGDRuGpKSk3NfFxsaq70jeU967Z8+eOHv2bLE/IxFRaWACQESkMTkxlZPX6OhodVL677//on///hgzZgxu3ryJn3/+WZ2gfv7557e91traGi+//DK+/vrr3G06nU7df+WVV3K3Xb16VZ28hoWFqdsjR47g448/Vo9lZWWpk1pJRE6ePInw8HC1jz59+qjH9H777Tc88sgjuH79Or799lu88847eOaZZ1SyISe+chVeEoU7kZP+VatWqefKCbq814gRI0r8/Uni0axZM2zdulXdl/glzldffRXXrl3Drl27sHbtWnz44YfqcXn/Hj16qORBvt8lS5ZgwYIFt+3377//hp2dnTqBP3DggEpWHnroIbXvixcvIjg4WH2Gt956K/d7l5+bJFaHDx9WCVRgYKD6btlFiYiMio6IiMpchw4ddA4ODjoPDw+dt7e3rlmzZrpFixapx15++WVdv3798j3/k08+0dWrVy/3vvz63rp1q1q/evWqzt7eXnf06FF1f/v27TpXV1ddfHy8uv/999+r90pPT899/ahRo3Tdu3dX63v37tVZWVnpoqOjcx+PiopS2/bt26fuP/vss7pOnTrli8nT01M3Y8aM3PsHDhxQccXGxqr7kyZN0rVt2/aO38GqVat0Xl5euffv9fy7Pf7444/runTpotZHjBihe+KJJ/I9vmTJEl2tWrXU+uLFi3W+vr66rKys3Me/+OILFXve96pUqZIuOzs7d9vHH3+sa9WqVb797tmzR333mZmZuoMHD+rs7Ox0CQkJuY/LdkdHR93u3bvv+LmIiMqardYJCBGRpRo1ahQ++OCD27ZLtxq5qp1X7dq11VXnwkh3lAEDBqguPtJKILdPPvmk6t6iJ1125Gq2nouLCxISEnLfz8vLC+XKlct9XLqvyH15z1atWqltfn5++d5X9pF3m9wXsl/pZlSQXP2X1oLTp08jNTVVdV+S7jPSyiCtDyUhcUr3JnHq1Cns2LEDnp6euY/Le+m7UEl3p6pVq6rWEz39a/OSbjx5uwXJfqWLVt79Si4mz5EWFnlcWnOku1VB8h0TERkLdgEiIjIycnJ65syZfNvkfrVq1e74Gul3Lt2ILly4gNWrV6vuL/fzflKILIuedEeS+3d7z/sRERGh6g6ky4+crEs3GX2f/ZwGjeKTbk2HDh1SXZD0XY0kAZKuPvpF3k+Kh4X03ZcT8rw1FfK9FZQ3QdDvV+oC8u43Li5OJTOyT3lcRna6ceNGvuekpKRgyJAhJfqMRESGxASAiMjIvPDCC6oIeOXKlerquPQn/+ijj1Rf/ztp3769OgmVlgApWNUXABfFAw88oIpzhw8frk6U5aT29ddfV/uRmgRDkJNvOeGWlghHR0d1tXzmzJkl2qe0Hsj31K9fP/UZpKhYSGHuihUr8Ouvv6rRe+Q7lFaHTZs2qcelT75sl/eXW+nHX1h9RUHPP/+8+lnMnz8fycnJKnGRREJqI4QkB/I9SjImdRJCkij5OcrziYiMBRMAIiIj8+CDD6oT2OnTp6tuOHLl/I033sCbb75519fJiadcCb+fq/9Cut+sW7cOaWlpqqtRnTp1VFcWKZwtadccvfr166sTbikalq5Jzz77rBr56H7JaD/6eQCki87s2bNV4rJ9+/bcLk6StEhB8DfffKOSIunONGjQoNyr/NKFZ8OGDaqlRLo+SWuBJF0ODg53fW9pDZH3l33XqlVL7UdGQAoNDVWPy3cljzk7O6ufoXzOxo0bq/fJ25WIiEhrVlIIoHUQRERUchs3blRdTWT0GTkJpaKTIU2/+uorNYIQEZG5YwsAEZEZkC4mcjVchv7kyf+9SYuBdN+Ra2AyxKcUJz/11FNah0VEVCaYABARmTi5ci1968X48eO1DsckyFwI0k1HRi6S7kHSHUnmXSAisgTsAkREREREZEHYAkBEREREZEGYABARERERWRAmAEREREREFoQJABERERGRBWECQERERERkQZgAEBERERFZECYAREREREQWhAkAEREREZEFYQJARERERGRBmAAQEREREVkQJgBERERERBaECQARERERkQVhAkBEREREZEGYABARERERwXL8P2/sTB17L7/+AAAAAElFTkSuQmCC" width="768" style="display: block; margin: auto;" /></p>
<p>We determine the optimal polynomial degree by selecting the one that
yields the lowest average MSE across all folds in 10-fold
cross-validation.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="co"># Find the best degree according to average MSE over 10-folds</span></span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a>best_degree <span class="op">=</span> degrees[np.argmin(mse_scores)]</span>
<span id="cb40-3"><a href="#cb40-3" tabindex="-1"></a>best_mse <span class="op">=</span> <span class="bu">min</span>(mse_scores)</span>
<span id="cb40-4"><a href="#cb40-4" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Best polynomial degree: </span><span class="sc">{</span>best_degree<span class="sc">}</span><span class="ss"> with MSE: </span><span class="sc">{</span>best_mse<span class="sc">:.2f}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<pre><code>## Best polynomial degree: 4 with MSE: 2645116.85</code></pre>
<p>It is clear that regressing <code>price</code> on
<code>carat</code><span class="math inline">\(^4\)</span> yields the
lowest average MSE among the polynomial degrees considered. However,
this may not represent the global minimum, and it is worth exploring
higher-degree polynomials to see if further improvements in model
performance can be achieved.</p>
</div>
</div>
<div id="exercise-2-1" class="section level1">
<h1>Exercise 2</h1>
<p>The <code>penguins</code> dataset contains size measurements for
three penguin species observed on islands in the Palmer Archipelago,
Antarctica. This dataset is available through the
<code>palmerpenguins</code> package or via <code>seaborn</code>
package.</p>
<p>The dataset includes the following variables:</p>
<ul>
<li><p><strong>species</strong>: penguin species (Adelie, Gentoo,
Chinstrap),</p></li>
<li><p><strong>island</strong>: island where the penguin was
observed,</p></li>
<li><p><strong>bill_length_mm</strong>: length of the bill
(millimeters),</p></li>
<li><p><strong>bill_depth_mm</strong>: depth of the bill
(millimeters),</p></li>
<li><p><strong>flipper_length_mm</strong>: length of the flipper
(millimeters),</p></li>
<li><p><strong>body_mass_g</strong>: body mass (grams),</p></li>
<li><p><strong>sex</strong>: sex of the penguin,</p></li>
<li><p><strong>year</strong>: year of observation.</p></li>
</ul>
<ol style="list-style-type: decimal">
<li><p>Fit a linear regression model to predict <code>body_mass_g</code>
using <code>bill_length_mm</code> and <code>flipper_length_mm</code> as
predictors. Use only complete cases.</p></li>
<li><p>Use the validation set approach: randomly split the data into a
training set <span class="math inline">\((70%)\)</span> and a test set
<span class="math inline">\((30%)\)</span>. Fit the model on the
training set and compute the test Mean Squared Error (MSE).</p></li>
<li><p>Repeat <strong>Exercise 2.2.</strong> <span class="math inline">\(50\)</span> times using different random seeds.
Report the average test MSE and its standard deviation across all
repetitions.</p></li>
<li><p>Use 10-fold cross-validation (e.g., <code>cross_val_score</code>
from <code>sklearn.model_selection</code>) to estimate the test error of
the model. Compare this with the average test MSE from repeated
validation.</p></li>
<li><p>Use the bootstrap method (e.g. using <code>statsmodels</code>) to
estimate the standard errors of the regression coefficients. Compare
with those reported by the <code>summary()</code> output from
<code>statsmodels.OLS</code>.</p></li>
</ol>
<button onclick="toggleSolution(this)">
Show/Hide Solution
</button>
<div class="solution" style="display:none;">
<p>We start by loading <code>penguins</code> dataset. We clean the data
by removing rows that contain missing values in the variables of
interest (<code>body_mass_g</code>, <code>bill_length_mm</code>,
<code>flipper_length_mm</code>).</p>
<p>Next, we separate the dataset into:</p>
<ul>
<li><p><strong>X</strong> - a data frame containing the predictor
variables <code>bill_length_mm</code> and
<code>flipper_length_mm</code>,</p></li>
<li><p><strong>y</strong> - a vector containing the response variable
<code>body_mass_g</code>.</p></li>
</ul>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb42-2"><a href="#cb42-2" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb42-3"><a href="#cb42-3" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split, cross_val_score, KFold</span>
<span id="cb42-4"><a href="#cb42-4" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LinearRegression</span>
<span id="cb42-5"><a href="#cb42-5" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> mean_squared_error</span>
<span id="cb42-6"><a href="#cb42-6" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb42-7"><a href="#cb42-7" tabindex="-1"></a><span class="im">from</span> sklearn.utils <span class="im">import</span> resample</span>
<span id="cb42-8"><a href="#cb42-8" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb42-9"><a href="#cb42-9" tabindex="-1"></a></span>
<span id="cb42-10"><a href="#cb42-10" tabindex="-1"></a><span class="co"># set seed for reproducibility</span></span>
<span id="cb42-11"><a href="#cb42-11" tabindex="-1"></a>np.random.seed(<span class="dv">103</span>) </span>
<span id="cb42-12"><a href="#cb42-12" tabindex="-1"></a></span>
<span id="cb42-13"><a href="#cb42-13" tabindex="-1"></a><span class="co"># Load dataset</span></span>
<span id="cb42-14"><a href="#cb42-14" tabindex="-1"></a>penguins <span class="op">=</span> sns.load_dataset(<span class="st">&quot;penguins&quot;</span>)</span>
<span id="cb42-15"><a href="#cb42-15" tabindex="-1"></a></span>
<span id="cb42-16"><a href="#cb42-16" tabindex="-1"></a><span class="co"># Drop rows with missing values at important variables</span></span>
<span id="cb42-17"><a href="#cb42-17" tabindex="-1"></a>penguins_clean <span class="op">=</span> penguins.dropna(subset<span class="op">=</span>[<span class="st">&quot;body_mass_g&quot;</span>, <span class="st">&quot;bill_length_mm&quot;</span>, <span class="st">&quot;flipper_length_mm&quot;</span>])</span>
<span id="cb42-18"><a href="#cb42-18" tabindex="-1"></a></span>
<span id="cb42-19"><a href="#cb42-19" tabindex="-1"></a><span class="co"># Features and target defined seperately, for clarity of code</span></span>
<span id="cb42-20"><a href="#cb42-20" tabindex="-1"></a>X <span class="op">=</span> penguins_clean[[<span class="st">&quot;bill_length_mm&quot;</span>, <span class="st">&quot;flipper_length_mm&quot;</span>]]</span>
<span id="cb42-21"><a href="#cb42-21" tabindex="-1"></a>y <span class="op">=</span> penguins_clean[<span class="st">&quot;body_mass_g&quot;</span>]</span></code></pre></div>
<p>We fit model <code>body_mass_g</code>~<code>bill_length_mm</code> +
<code>flipper_length_mm</code> using <code>OLS()</code> function.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a><span class="co"># Fit a linear regression model on the full clean dataset</span></span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a>X_const <span class="op">=</span> sm.add_constant(X)</span>
<span id="cb43-3"><a href="#cb43-3" tabindex="-1"></a>model_full <span class="op">=</span> sm.OLS(y, X_const).fit()<span class="op">;</span></span></code></pre></div>
<p>We perform a repeated validation set approach to estimate the
prediction error of our linear regression model.</p>
<p>The dataset is split randomly <span class="math inline">\(50\)</span>
times, with <span class="math inline">\(70\%\)</span> of the data used
for training and <span class="math inline">\(30\%\)</span> for testing
in each iteration. A different seed is set for each iteration to ensure
randomness and reproducibility.</p>
<p>In each iteration:</p>
<ul>
<li><p>A linear regression model is fit using only the training data to
predict body_mass_g from bill_length_mm and flipper_length_mm.</p></li>
<li><p>The model’s predictions are then evaluated on the test set using
Mean Squared Error (MSE).</p></li>
<li><p>The computed MSE is stored for later analysis.</p></li>
</ul>
<p>After all iterations we compute the average MSE to estimate the
model’s typical prediction error on unseen data.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="co"># Repeated validation set approach</span></span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a>mse_list <span class="op">=</span> []</span>
<span id="cb44-3"><a href="#cb44-3" tabindex="-1"></a><span class="cf">for</span> seed <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">50</span>):</span>
<span id="cb44-4"><a href="#cb44-4" tabindex="-1"></a>    <span class="co"># For each seed we create test and train set</span></span>
<span id="cb44-5"><a href="#cb44-5" tabindex="-1"></a>    X_train, X_test, y_train, y_test <span class="op">=</span> train_test_split(</span>
<span id="cb44-6"><a href="#cb44-6" tabindex="-1"></a>        X, y, test_size<span class="op">=</span><span class="fl">0.3</span>, random_state<span class="op">=</span>seed</span>
<span id="cb44-7"><a href="#cb44-7" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb44-8"><a href="#cb44-8" tabindex="-1"></a>    lm <span class="op">=</span> LinearRegression()<span class="op">;</span></span>
<span id="cb44-9"><a href="#cb44-9" tabindex="-1"></a>    lm.fit(X_train, y_train)<span class="op">;</span></span>
<span id="cb44-10"><a href="#cb44-10" tabindex="-1"></a>    <span class="co"># Test MSE is calculated on test set</span></span>
<span id="cb44-11"><a href="#cb44-11" tabindex="-1"></a>    y_pred <span class="op">=</span> lm.predict(X_test)<span class="op">;</span></span>
<span id="cb44-12"><a href="#cb44-12" tabindex="-1"></a>    <span class="co"># and store MSE</span></span>
<span id="cb44-13"><a href="#cb44-13" tabindex="-1"></a>    mse <span class="op">=</span> mean_squared_error(y_test, y_pred)<span class="op">;</span></span>
<span id="cb44-14"><a href="#cb44-14" tabindex="-1"></a>    mse_list.append(mse)<span class="op">;</span></span>
<span id="cb44-15"><a href="#cb44-15" tabindex="-1"></a>    </span>
<span id="cb44-16"><a href="#cb44-16" tabindex="-1"></a><span class="co"># Here we average over all 50 seeds</span></span>
<span id="cb44-17"><a href="#cb44-17" tabindex="-1"></a>avg_mse <span class="op">=</span> np.mean(mse_list)<span class="op">;</span></span>
<span id="cb44-18"><a href="#cb44-18" tabindex="-1"></a>std_mse <span class="op">=</span> np.std(mse_list)<span class="op">;</span></span>
<span id="cb44-19"><a href="#cb44-19" tabindex="-1"></a></span>
<span id="cb44-20"><a href="#cb44-20" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Average Test MSE (Repeated Validation):&quot;</span>, <span class="bu">round</span>(avg_mse, <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
<pre><code>## Average Test MSE (Repeated Validation): 153804.24</code></pre>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Standard Deviation of Test MSE:&quot;</span>, <span class="bu">round</span>(std_mse, <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
<pre><code>## Standard Deviation of Test MSE: 17571.23</code></pre>
<p>Repeated validation gives us average MSE of <code>153804.24</code>
(in grams), which might seems large but corresponds to <span class="math inline">\(\sqrt{153804.24} \approx 392.17\)</span> grams on
average.</p>
<p>We apply 10-fold cross-validation in a similar way and compare the
results from these two approaches.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a><span class="co"># Define a LinearRegression object to store cross-validated model</span></span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a>lm_cv <span class="op">=</span> LinearRegression()</span>
<span id="cb48-3"><a href="#cb48-3" tabindex="-1"></a><span class="co"># KFold function allows you to perform cross-validation without </span></span>
<span id="cb48-4"><a href="#cb48-4" tabindex="-1"></a><span class="co"># creating folds yourself. Just specify amount of folds with argument</span></span>
<span id="cb48-5"><a href="#cb48-5" tabindex="-1"></a><span class="co"># n_splits. Also random_state argument allows for reproducibility</span></span>
<span id="cb48-6"><a href="#cb48-6" tabindex="-1"></a>cv <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">10</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">103</span>)</span>
<span id="cb48-7"><a href="#cb48-7" tabindex="-1"></a>cv_mse <span class="op">=</span> <span class="op">-</span>cross_val_score(lm_cv, X, y, scoring<span class="op">=</span><span class="st">&quot;neg_mean_squared_error&quot;</span>, cv<span class="op">=</span>cv)</span>
<span id="cb48-8"><a href="#cb48-8" tabindex="-1"></a></span>
<span id="cb48-9"><a href="#cb48-9" tabindex="-1"></a><span class="co"># Average MSE and Std, averaged over folds</span></span>
<span id="cb48-10"><a href="#cb48-10" tabindex="-1"></a>cv_mse_mean <span class="op">=</span> cv_mse.mean()</span>
<span id="cb48-11"><a href="#cb48-11" tabindex="-1"></a>cv_mse_std <span class="op">=</span> cv_mse.std()</span>
<span id="cb48-12"><a href="#cb48-12" tabindex="-1"></a></span>
<span id="cb48-13"><a href="#cb48-13" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;10-Fold CV MSE:&quot;</span>, <span class="bu">round</span>(cv_mse_mean, <span class="dv">2</span>), <span class="st">&quot;±&quot;</span>, <span class="bu">round</span>(cv_mse_std, <span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
<pre><code>## 10-Fold CV MSE: 155471.76 ± 47447.15</code></pre>
<p>10-fold cross-validation produces average MSE of
<code>155471.76</code> which is a bit higher than what we obtained with
repeated validation. However, the standard deviation is significantly
higher.</p>
<p>We now proceed to apply the bootstrap method to estimate the standard
errors of the model coefficients.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a><span class="co"># Bootstrap to estimate standard errors of coefficients</span></span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a>n_bootstraps <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb50-3"><a href="#cb50-3" tabindex="-1"></a>coefs <span class="op">=</span> np.zeros((n_bootstraps, X.shape[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>))  <span class="co"># +1 for intercept</span></span>
<span id="cb50-4"><a href="#cb50-4" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_bootstraps):</span>
<span id="cb50-6"><a href="#cb50-6" tabindex="-1"></a>    X_resampled, y_resampled <span class="op">=</span> resample(X, y)</span>
<span id="cb50-7"><a href="#cb50-7" tabindex="-1"></a>    X_resampled_const <span class="op">=</span> sm.add_constant(X_resampled)</span>
<span id="cb50-8"><a href="#cb50-8" tabindex="-1"></a>    model <span class="op">=</span> sm.OLS(y_resampled, X_resampled_const).fit()</span>
<span id="cb50-9"><a href="#cb50-9" tabindex="-1"></a>    coefs[i, :] <span class="op">=</span> model.params</span>
<span id="cb50-10"><a href="#cb50-10" tabindex="-1"></a></span>
<span id="cb50-11"><a href="#cb50-11" tabindex="-1"></a>bootstrap_se <span class="op">=</span> coefs.std(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb50-12"><a href="#cb50-12" tabindex="-1"></a></span>
<span id="cb50-13"><a href="#cb50-13" tabindex="-1"></a><span class="co"># Organize results</span></span>
<span id="cb50-14"><a href="#cb50-14" tabindex="-1"></a>coef_names <span class="op">=</span> [<span class="st">&quot;Intercept&quot;</span>] <span class="op">+</span> <span class="bu">list</span>(X.columns)</span>
<span id="cb50-15"><a href="#cb50-15" tabindex="-1"></a>summary_df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb50-16"><a href="#cb50-16" tabindex="-1"></a>    <span class="st">&quot;Coefficient&quot;</span>: coef_names,</span>
<span id="cb50-17"><a href="#cb50-17" tabindex="-1"></a>    <span class="st">&quot;OLS Std. Err.&quot;</span>: model_full.bse.values,</span>
<span id="cb50-18"><a href="#cb50-18" tabindex="-1"></a>    <span class="st">&quot;Bootstrap Std. Err.&quot;</span>: bootstrap_se</span>
<span id="cb50-19"><a href="#cb50-19" tabindex="-1"></a>})</span>
<span id="cb50-20"><a href="#cb50-20" tabindex="-1"></a></span>
<span id="cb50-21"><a href="#cb50-21" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Standard errors comparison (OLS vs Bootstrap):&quot;</span>)</span></code></pre></div>
<pre><code>## Standard errors comparison (OLS vs Bootstrap):</code></pre>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a><span class="bu">print</span>(summary_df)</span></code></pre></div>
<pre><code>##          Coefficient  OLS Std. Err.  Bootstrap Std. Err.
## 0          Intercept     307.959128           283.590856
## 1     bill_length_mm       5.179831             4.927403
## 2  flipper_length_mm       2.011115             1.785445</code></pre>
<p>Standard deviation estimates are similar for both bootstrap and OLS,
which are obtained using asymptotic results. However, all of bootstrap
estimates are lower. There is no a priori reason to assume that one of
these two is better/closer to real standard deviations. Bootstrap,
however, is more robust to violations of assumptions.</p>
</div>
</div>
<div id="exercise-3-1" class="section level1">
<h1>Exercise 3</h1>
<p>The <code>numpy</code>, <code>scipy</code>, and
<code>scikit</code>-learn libraries can be used to simulate and
bootstrap statistics in Python. In this exercise, you will work with
synthetic data and apply the bootstrap to estimate standard error and
bias.</p>
<ol style="list-style-type: decimal">
<li>Generate a population of <span class="math inline">\(100
000\)</span> observations from a standard normal distribution:</li>
</ol>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a>population <span class="op">=</span> np.random.normal(loc<span class="op">=</span><span class="dv">0</span>, scale<span class="op">=</span><span class="dv">1</span>, size<span class="op">=</span><span class="dv">100000</span>)</span></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li><p>Use Monte Carlo simulation to estimate the true sampling
distribution of the sample median:</p>
<ul>
<li><p>the following 10000 times:</p></li>
<li><p>Draw a sample of size 100 from the population.</p></li>
<li><p>Compute the median.</p></li>
<li><p>Store the results and compute the standard deviation and bias
relative to the true median.</p></li>
</ul></li>
<li><p>Draw a single random sample of size <span class="math inline">\(100\)</span> from the population and compute the
sample median.</p></li>
<li><p>Apply the bootstrap (1000 resamples) to estimate the standard
error and bias of the median:</p>
<ul>
<li><p>Resample with replacement from the single sample.</p></li>
<li><p>Compute the median for each bootstrap sample.</p></li>
<li><p>Calculate the standard deviation and bias of the bootstrapped
medians.</p></li>
</ul></li>
<li><p>Compare the bootstrap estimates to the values obtained from the
Monte Carlo simulation. Are they close?</p></li>
<li><p>Repeat <strong>Exercise 3.3</strong> to <strong>Exercise
3.5</strong> using the interquartile range (IQR) instead of the median.
Discuss any differences.</p></li>
</ol>
<button onclick="toggleSolution(this)">
Show/Hide Solution
</button>
<div class="solution" style="display:none;">
<p>We generate <span class="math inline">\(100 000\)</span> observations
from the standard normal distribution <span class="math inline">\(\mathcal{N}(0,1)\)</span>, which will serve as our
approximation of the population.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb55-2"><a href="#cb55-2" tabindex="-1"></a></span>
<span id="cb55-3"><a href="#cb55-3" tabindex="-1"></a><span class="co"># Set seed for reproducibility</span></span>
<span id="cb55-4"><a href="#cb55-4" tabindex="-1"></a>np.random.seed(<span class="dv">103</span>) </span>
<span id="cb55-5"><a href="#cb55-5" tabindex="-1"></a></span>
<span id="cb55-6"><a href="#cb55-6" tabindex="-1"></a><span class="co"># Generate 100 000 observations. These will serve as general population</span></span>
<span id="cb55-7"><a href="#cb55-7" tabindex="-1"></a>population <span class="op">=</span> np.random.normal(loc<span class="op">=</span><span class="dv">0</span>, scale<span class="op">=</span><span class="dv">1</span>, size<span class="op">=</span><span class="dv">100000</span>)</span></code></pre></div>
<p>We want to approximate the sampling distribution of the median based
on samples of size <span class="math inline">\(100\)</span>. We
repeatedly draw samples of 100 observations from the generated
population and compute the median for each sample.</p>
<p>The resulting distribution of medians allows us to estimate both the
standard deviation (as a measure of variability) and the bias of the
sample median as an estimator.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a><span class="co"># Monte Carlo simulation for sampling distribution of the median</span></span>
<span id="cb56-2"><a href="#cb56-2" tabindex="-1"></a>n_sim <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb56-3"><a href="#cb56-3" tabindex="-1"></a>sample_size <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb56-4"><a href="#cb56-4" tabindex="-1"></a>medians_mc <span class="op">=</span> np.array([</span>
<span id="cb56-5"><a href="#cb56-5" tabindex="-1"></a>    np.median(np.random.choice(population, size<span class="op">=</span>sample_size, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb56-6"><a href="#cb56-6" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_sim)</span>
<span id="cb56-7"><a href="#cb56-7" tabindex="-1"></a>])</span>
<span id="cb56-8"><a href="#cb56-8" tabindex="-1"></a></span>
<span id="cb56-9"><a href="#cb56-9" tabindex="-1"></a>mc_std_median <span class="op">=</span> np.std(medians_mc)</span>
<span id="cb56-10"><a href="#cb56-10" tabindex="-1"></a></span>
<span id="cb56-11"><a href="#cb56-11" tabindex="-1"></a><span class="co"># Bias of median estimator. Note that we subtract np.mean(population), which is &quot;true&quot;</span></span>
<span id="cb56-12"><a href="#cb56-12" tabindex="-1"></a><span class="co"># median in population, rather than theoretical median which is 0.</span></span>
<span id="cb56-13"><a href="#cb56-13" tabindex="-1"></a>mc_bias_median <span class="op">=</span> np.mean(medians_mc) <span class="op">-</span> np.mean(population)</span></code></pre></div>
<p>We now examine the performance of the bootstrap method by generating
a single sample from the dataset and applying the bootstrap procedure
based solely on this sample.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a><span class="co"># Draw single sample and compute sample median</span></span>
<span id="cb57-2"><a href="#cb57-2" tabindex="-1"></a>sample <span class="op">=</span> np.random.choice(population, size<span class="op">=</span>sample_size, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb57-3"><a href="#cb57-3" tabindex="-1"></a>sample_median <span class="op">=</span> np.median(sample)</span></code></pre></div>
<p>Bootstrap can be performed using <code>np.random.choice()</code>
function from <code>numpy</code> package. Contrary to R, we do not need
to define separate function.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a><span class="co"># Bootstrap estimation of SE and bias for the median</span></span>
<span id="cb58-2"><a href="#cb58-2" tabindex="-1"></a>n_boot <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb58-3"><a href="#cb58-3" tabindex="-1"></a>boot_medians <span class="op">=</span> np.array([</span>
<span id="cb58-4"><a href="#cb58-4" tabindex="-1"></a>    np.median(np.random.choice(sample, size<span class="op">=</span>sample_size, replace<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb58-5"><a href="#cb58-5" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_boot)</span>
<span id="cb58-6"><a href="#cb58-6" tabindex="-1"></a>])</span>
<span id="cb58-7"><a href="#cb58-7" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" tabindex="-1"></a>boot_std_median <span class="op">=</span> np.std(boot_medians)</span>
<span id="cb58-9"><a href="#cb58-9" tabindex="-1"></a>boot_bias_median <span class="op">=</span> np.mean(boot_medians) <span class="op">-</span> sample_median</span></code></pre></div>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a><span class="co"># Step 5: Compare Monte Carlo to Bootstrap for median in table form</span></span>
<span id="cb59-2"><a href="#cb59-2" tabindex="-1"></a>median_results <span class="op">=</span> pd.DataFrame({</span>
<span id="cb59-3"><a href="#cb59-3" tabindex="-1"></a>    <span class="st">&quot;Method&quot;</span>: [<span class="st">&quot;Monte Carlo&quot;</span>, <span class="st">&quot;Bootstrap&quot;</span>],</span>
<span id="cb59-4"><a href="#cb59-4" tabindex="-1"></a>    <span class="st">&quot;SE&quot;</span>: [mc_std_median, boot_std_median],</span>
<span id="cb59-5"><a href="#cb59-5" tabindex="-1"></a>    <span class="st">&quot;Bias&quot;</span>: [mc_bias_median, boot_bias_median]</span>
<span id="cb59-6"><a href="#cb59-6" tabindex="-1"></a>})</span>
<span id="cb59-7"><a href="#cb59-7" tabindex="-1"></a>median_results</span></code></pre></div>
<pre><code>##         Method        SE      Bias
## 0  Monte Carlo  0.123963  0.004970
## 1    Bootstrap  0.130508 -0.029083</code></pre>
<p>The results obtained using the Monte Carlo method can be treated as
benchmark estimates, as they are based on repeated sampling from the
full population. The bootstrap estimates, which rely on just a single
sample, are quite close to these reference values. The difference in
standard error is approximately <span class="math inline">\(0.01\)</span>, and the bias differs by about <span class="math inline">\(0.05\)</span>.</p>
<p>We will now repeat entire process for IQR.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" tabindex="-1"></a><span class="co"># Monte Carlo</span></span>
<span id="cb61-2"><a href="#cb61-2" tabindex="-1"></a>iqrs_mc <span class="op">=</span> np.array([</span>
<span id="cb61-3"><a href="#cb61-3" tabindex="-1"></a>    np.percentile(np.random.choice(population, size<span class="op">=</span>sample_size, replace<span class="op">=</span><span class="va">False</span>), <span class="dv">75</span>) <span class="op">-</span></span>
<span id="cb61-4"><a href="#cb61-4" tabindex="-1"></a>    np.percentile(np.random.choice(population, size<span class="op">=</span>sample_size, replace<span class="op">=</span><span class="va">False</span>), <span class="dv">25</span>)</span>
<span id="cb61-5"><a href="#cb61-5" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_sim)</span>
<span id="cb61-6"><a href="#cb61-6" tabindex="-1"></a>])</span>
<span id="cb61-7"><a href="#cb61-7" tabindex="-1"></a>mc_std_iqr <span class="op">=</span> np.std(iqrs_mc)</span>
<span id="cb61-8"><a href="#cb61-8" tabindex="-1"></a>mc_bias_iqr <span class="op">=</span> np.mean(iqrs_mc) <span class="op">-</span> np.percentile(population, <span class="dv">75</span>) <span class="op">+</span> np.percentile(population, <span class="dv">25</span>)</span>
<span id="cb61-9"><a href="#cb61-9" tabindex="-1"></a></span>
<span id="cb61-10"><a href="#cb61-10" tabindex="-1"></a><span class="co"># Bootstrap</span></span>
<span id="cb61-11"><a href="#cb61-11" tabindex="-1"></a>sample_iqr <span class="op">=</span> np.percentile(sample, <span class="dv">75</span>) <span class="op">-</span> np.percentile(sample, <span class="dv">25</span>)</span>
<span id="cb61-12"><a href="#cb61-12" tabindex="-1"></a>boot_iqrs <span class="op">=</span> np.array([</span>
<span id="cb61-13"><a href="#cb61-13" tabindex="-1"></a>    np.percentile(np.random.choice(sample, size<span class="op">=</span>sample_size, replace<span class="op">=</span><span class="va">True</span>), <span class="dv">75</span>) <span class="op">-</span></span>
<span id="cb61-14"><a href="#cb61-14" tabindex="-1"></a>    np.percentile(np.random.choice(sample, size<span class="op">=</span>sample_size, replace<span class="op">=</span><span class="va">True</span>), <span class="dv">25</span>)</span>
<span id="cb61-15"><a href="#cb61-15" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_boot)</span>
<span id="cb61-16"><a href="#cb61-16" tabindex="-1"></a>])</span>
<span id="cb61-17"><a href="#cb61-17" tabindex="-1"></a>boot_std_iqr <span class="op">=</span> np.std(boot_iqrs)</span>
<span id="cb61-18"><a href="#cb61-18" tabindex="-1"></a>boot_bias_iqr <span class="op">=</span> np.mean(boot_iqrs) <span class="op">-</span> sample_iqr</span>
<span id="cb61-19"><a href="#cb61-19" tabindex="-1"></a></span>
<span id="cb61-20"><a href="#cb61-20" tabindex="-1"></a><span class="co"># Results table</span></span>
<span id="cb61-21"><a href="#cb61-21" tabindex="-1"></a>iqr_results <span class="op">=</span> pd.DataFrame({</span>
<span id="cb61-22"><a href="#cb61-22" tabindex="-1"></a>    <span class="st">&quot;Method&quot;</span>: [<span class="st">&quot;Monte Carlo&quot;</span>, <span class="st">&quot;Bootstrap&quot;</span>],</span>
<span id="cb61-23"><a href="#cb61-23" tabindex="-1"></a>    <span class="st">&quot;SE&quot;</span>: [mc_std_iqr, boot_std_iqr],</span>
<span id="cb61-24"><a href="#cb61-24" tabindex="-1"></a>    <span class="st">&quot;Bias&quot;</span>: [mc_bias_iqr, boot_bias_iqr]</span>
<span id="cb61-25"><a href="#cb61-25" tabindex="-1"></a>})</span>
<span id="cb61-26"><a href="#cb61-26" tabindex="-1"></a>iqr_results</span></code></pre></div>
<pre><code>##         Method        SE      Bias
## 0  Monte Carlo  0.189558 -0.019779
## 1    Bootstrap  0.153965  0.016931</code></pre>
<p>The Standard Error of the IQR estimated using the bootstrap method is
close to the value obtained via Monte Carlo simulation. While the bias
estimated by the bootstrap is slightly larger, the overall difference
(approximately <span class="math inline">\(0.002\)</span>) remains
relatively small, demonstrating that bootstrap can still provide useful
insights, especially when access to the full population is limited.</p>
</div>
</div>
<div id="exercise-4-1" class="section level1">
<h1>Exercise 4</h1>
<p>In this exercise, you will explore the stability of model selection
using repeated cross-validation. The goal is to examine how often
different linear models are selected as the best based on
cross-validated mean squared error.</p>
<ol style="list-style-type: decimal">
<li>Load the penguins dataset. You can use <code>seaborn</code>:</li>
</ol>
<div class="sourceCode" id="cb63"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb63-2"><a href="#cb63-2" tabindex="-1"></a>penguins <span class="op">=</span> sns.load_dataset(<span class="st">&quot;penguins&quot;</span>)</span></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li><p>Define a set of 4 candidate models to predict
<code>body_mass_g</code>:</p>
<ul>
<li><p>Model 1: <code>body_mass_g</code> ~
<code>flipper_length_mm</code></p></li>
<li><p>Model 2: <code>body_mass_g</code> ~
<code>flipper_length_mm</code> + <code>bill_length_mm</code></p></li>
<li><p>Model 2: <code>body_mass_g</code> ~
<code>flipper_length_mm</code> + <code>bill_depth_mm</code></p></li>
<li><p>Model 4: <code>body_mass_g</code> ~
<code>flipper_length_mm</code> + <code>bill_length_mm</code> +
<code>bill_depth_mm</code></p></li>
</ul></li>
</ol>
<p>3.Perform the following steps <span class="math inline">\(100\)</span> times:</p>
<pre><code>- Randomly split the data into 10 folds.

- Use 10-fold CV to estimate the test MSE of each model.

- Record which model has the lowest estimated test MSE.</code></pre>
<ol start="4" style="list-style-type: decimal">
<li><p>After all repetitions, report the selection frequency of each
model.</p></li>
<li><p>Visualize the model selection frequencies as a bar plot.</p></li>
</ol>
<button onclick="toggleSolution(this)">
Show/Hide Solution
</button>
<div class="solution" style="display:none;">
<div class="sourceCode" id="cb65"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" tabindex="-1"></a><span class="co"># Import libraries and set seed</span></span>
<span id="cb65-2"><a href="#cb65-2" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb65-3"><a href="#cb65-3" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb65-4"><a href="#cb65-4" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb65-5"><a href="#cb65-5" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt<span class="op">;</span></span>
<span id="cb65-6"><a href="#cb65-6" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LinearRegression</span>
<span id="cb65-7"><a href="#cb65-7" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> cross_val_score, KFold</span>
<span id="cb65-8"><a href="#cb65-8" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> mean_squared_error</span>
<span id="cb65-9"><a href="#cb65-9" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> OneHotEncoder</span>
<span id="cb65-10"><a href="#cb65-10" tabindex="-1"></a><span class="im">from</span> sklearn.compose <span class="im">import</span> ColumnTransformer</span>
<span id="cb65-11"><a href="#cb65-11" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline</span>
<span id="cb65-12"><a href="#cb65-12" tabindex="-1"></a></span>
<span id="cb65-13"><a href="#cb65-13" tabindex="-1"></a><span class="co"># Set seed for reproducibility</span></span>
<span id="cb65-14"><a href="#cb65-14" tabindex="-1"></a>np.random.seed(<span class="dv">103</span>) </span></code></pre></div>
<p>We load <code>penguins</code> dataset which is available in
<code>seaborn</code> package. To keep the code organized and readable,
we define a list containing four predefined models:
<code>Model 1</code>, <code>Model 2</code>, <code>Model 3</code>,
<code>Model 4</code>.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a><span class="co"># Load penguins dataset</span></span>
<span id="cb66-2"><a href="#cb66-2" tabindex="-1"></a>penguins <span class="op">=</span> sns.load_dataset(<span class="st">&quot;penguins&quot;</span>).dropna()</span></code></pre></div>
<div class="sourceCode" id="cb67"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" tabindex="-1"></a><span class="co"># Define predictors for each model</span></span>
<span id="cb67-2"><a href="#cb67-2" tabindex="-1"></a>features <span class="op">=</span> [</span>
<span id="cb67-3"><a href="#cb67-3" tabindex="-1"></a>    [<span class="st">&#39;flipper_length_mm&#39;</span>],</span>
<span id="cb67-4"><a href="#cb67-4" tabindex="-1"></a>    [<span class="st">&#39;flipper_length_mm&#39;</span>, <span class="st">&#39;bill_length_mm&#39;</span>],</span>
<span id="cb67-5"><a href="#cb67-5" tabindex="-1"></a>    [<span class="st">&#39;flipper_length_mm&#39;</span>, <span class="st">&#39;bill_depth_mm&#39;</span>],</span>
<span id="cb67-6"><a href="#cb67-6" tabindex="-1"></a>    [<span class="st">&#39;flipper_length_mm&#39;</span>, <span class="st">&#39;bill_length_mm&#39;</span>, <span class="st">&#39;bill_depth_mm&#39;</span>]</span>
<span id="cb67-7"><a href="#cb67-7" tabindex="-1"></a>]</span>
<span id="cb67-8"><a href="#cb67-8" tabindex="-1"></a>model_names <span class="op">=</span> [<span class="st">&quot;Model 1&quot;</span>, <span class="st">&quot;Model 2&quot;</span>, <span class="st">&quot;Model 3&quot;</span>,<span class="st">&quot;Model 4&quot;</span>]</span>
<span id="cb67-9"><a href="#cb67-9" tabindex="-1"></a>y <span class="op">=</span> penguins[<span class="st">&#39;body_mass_g&#39;</span>]</span></code></pre></div>
<p>We perform 10-fold cross-validation repeated <span class="math inline">\(100\)</span> times. In each repetition, the
dataset is randomly partitioned into <span class="math inline">\(10\)</span> folds. For each model, we compute the
average test MSE across all <span class="math inline">\(10\)</span>
folds. This process is repeated <span class="math inline">\(100\)</span>
times and in each iteration we record which model achieved the lowest
average MSE. This will allow us to see which of predictors are “strong”,
i.e. which are usually chosen.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a><span class="co"># Step: Repeated CV and model selection</span></span>
<span id="cb68-2"><a href="#cb68-2" tabindex="-1"></a>selection_counts <span class="op">=</span> {name: <span class="dv">0</span> <span class="cf">for</span> name <span class="kw">in</span> model_names}</span>
<span id="cb68-3"><a href="#cb68-3" tabindex="-1"></a>reps <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb68-4"><a href="#cb68-4" tabindex="-1"></a></span>
<span id="cb68-5"><a href="#cb68-5" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(reps):</span>
<span id="cb68-6"><a href="#cb68-6" tabindex="-1"></a>    kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">10</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb68-7"><a href="#cb68-7" tabindex="-1"></a>    mse_list <span class="op">=</span> []</span>
<span id="cb68-8"><a href="#cb68-8" tabindex="-1"></a></span>
<span id="cb68-9"><a href="#cb68-9" tabindex="-1"></a>    <span class="cf">for</span> fset <span class="kw">in</span> features:</span>
<span id="cb68-10"><a href="#cb68-10" tabindex="-1"></a>        X <span class="op">=</span> penguins[fset]</span>
<span id="cb68-11"><a href="#cb68-11" tabindex="-1"></a>        <span class="co"># Preprocessing for categorical variable &#39;sex&#39;</span></span>
<span id="cb68-12"><a href="#cb68-12" tabindex="-1"></a>        preprocessor <span class="op">=</span> ColumnTransformer([</span>
<span id="cb68-13"><a href="#cb68-13" tabindex="-1"></a>            (<span class="st">&#39;cat&#39;</span>, OneHotEncoder(drop<span class="op">=</span><span class="st">&#39;first&#39;</span>), [<span class="st">&#39;sex&#39;</span>])</span>
<span id="cb68-14"><a href="#cb68-14" tabindex="-1"></a>        ], remainder<span class="op">=</span><span class="st">&#39;passthrough&#39;</span>) <span class="cf">if</span> <span class="st">&#39;sex&#39;</span> <span class="kw">in</span> fset <span class="cf">else</span> <span class="st">&#39;passthrough&#39;</span></span>
<span id="cb68-15"><a href="#cb68-15" tabindex="-1"></a></span>
<span id="cb68-16"><a href="#cb68-16" tabindex="-1"></a>        model <span class="op">=</span> make_pipeline(preprocessor, LinearRegression())</span>
<span id="cb68-17"><a href="#cb68-17" tabindex="-1"></a>        scores <span class="op">=</span> cross_val_score(model, X, y, cv<span class="op">=</span>kf, scoring<span class="op">=</span><span class="st">&#39;neg_mean_squared_error&#39;</span>)</span>
<span id="cb68-18"><a href="#cb68-18" tabindex="-1"></a>        mse <span class="op">=</span> <span class="op">-</span>scores.mean()</span>
<span id="cb68-19"><a href="#cb68-19" tabindex="-1"></a>        mse_list.append(mse)</span>
<span id="cb68-20"><a href="#cb68-20" tabindex="-1"></a></span>
<span id="cb68-21"><a href="#cb68-21" tabindex="-1"></a>    best_model_idx <span class="op">=</span> np.argmin(mse_list)</span>
<span id="cb68-22"><a href="#cb68-22" tabindex="-1"></a>    selection_counts[model_names[best_model_idx]] <span class="op">+=</span> <span class="dv">1</span></span></code></pre></div>
<p>We display how many times each model was selected across the <span class="math inline">\(100\)</span> repetitions.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" tabindex="-1"></a><span class="co"># Convert results to DataFrame</span></span>
<span id="cb69-2"><a href="#cb69-2" tabindex="-1"></a>selection_df <span class="op">=</span> pd.DataFrame.from_dict(selection_counts, orient<span class="op">=</span><span class="st">&#39;index&#39;</span>, columns<span class="op">=</span>[<span class="st">&#39;Frequency&#39;</span>])</span>
<span id="cb69-3"><a href="#cb69-3" tabindex="-1"></a>selection_df <span class="op">=</span> selection_df.reset_index().rename(columns<span class="op">=</span>{<span class="st">&#39;index&#39;</span>: <span class="st">&#39;Model&#39;</span>})</span>
<span id="cb69-4"><a href="#cb69-4" tabindex="-1"></a>selection_df</span></code></pre></div>
<pre><code>##      Model  Frequency
## 0  Model 1         30
## 1  Model 2         10
## 2  Model 3         52
## 3  Model 4          8</code></pre>
<p>From the results, we observe that <code>Model 1</code> was selected
<span class="math inline">\(30\)</span> times, <code>Model 2</code> only
<span class="math inline">\(10\)</span> times, <code>Model 3</code> was
chosen most often (<span class="math inline">\(52\)</span> times) and
<code>Model 4</code> was selected <span class="math inline">\(8\)</span>
times.</p>
<p>To better visualize these outcomes, we plot the selection
frequencies.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" tabindex="-1"></a><span class="co"># Plot selection frequencies</span></span>
<span id="cb71-2"><a href="#cb71-2" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>))<span class="op">;</span></span>
<span id="cb71-3"><a href="#cb71-3" tabindex="-1"></a>plt.bar(selection_df[<span class="st">&#39;Model&#39;</span>], selection_df[<span class="st">&#39;Frequency&#39;</span>], color<span class="op">=</span><span class="st">&#39;#1f77b4&#39;</span>)<span class="op">;</span></span>
<span id="cb71-4"><a href="#cb71-4" tabindex="-1"></a>plt.xlabel(<span class="st">&quot;Model&quot;</span>)<span class="op">;</span></span>
<span id="cb71-5"><a href="#cb71-5" tabindex="-1"></a>plt.ylabel(<span class="st">&quot;Selection Frequency&quot;</span>)<span class="op">;</span></span>
<span id="cb71-6"><a href="#cb71-6" tabindex="-1"></a>plt.title(<span class="st">&quot;Model Selection Frequencies over 100 Repetitions&quot;</span>)<span class="op">;</span></span>
<span id="cb71-7"><a href="#cb71-7" tabindex="-1"></a>plt.grid(axis<span class="op">=</span><span class="st">&#39;y&#39;</span>)<span class="op">;</span></span>
<span id="cb71-8"><a href="#cb71-8" tabindex="-1"></a>plt.tight_layout()<span class="op">;</span></span>
<span id="cb71-9"><a href="#cb71-9" tabindex="-1"></a>plt.show()<span class="op">;</span></span></code></pre></div>
<p><img role="img" src="data:image/png;base64,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tDB59913m+MfTPOtFmj02Os6//rXv0wQaDt9+rTpK67/VwtY2vVEj3elSpVM3/W8aMAwbNgw059dC6/a2qTBWdeuXU3Qo15//XUTYN50000mvfr6uuuuyxEkFOR80/c3btwoW7duDfi/+j0o+7zT7yIxMdHkIw0KNK1aMNYAJ7da9WuvvdbsR98bPny4nC0N9rQAHUxr9rVgbn8eXU8DTA0Sg9fT72jHjh353rddqPavOc/PtUf3qYVk/Q71e9AWBQ1IVq1a5VtHu/Npa4N+p9p9Sbs4aQWI5gvtJqW0a19CQoIpnNvnfV7d/eyWFP9ueTp+IjcauOp3pdcDPcf0/IqPjzd5IzggDuVceOqpp0we0c+s+W3WrFnmWJ0pvwLnjAWgQGbNmmXpKbR9+3brlVdesSpUqGClpaVZBw4csIoXL2599NFH1qpVq8w6K1asMP8nMzPTqlatmtWxY8eAba1Zs8asN3XqVPN627ZtVrFixayJEycGrHfXXXeZ9XTftoYNG1qdOnUKWO/YsWNW5cqVrfvuu8+3rEOHDubxV7Kzs60777zTioqKMvspUaKE1a5dOyslJcV8Ntvq1avN+6+99lrA/587d65ZvnHjRvN69+7dBUqvvi5XrpzVq1evPNNqb3vGjBk53gv+rCNGjDDfiX5XNv0uGjdubCUkJPiWjRs3zmxz5syZAdu75JJLrL/97W/Wmej/ze1h71ef16hRwzp58mTA/wvlmPz+++9W2bJlzffjb9KkSWa7mnbb7bffbtWtW/eMx+Xxxx+3SpYsaf34448B6w0aNMjsOyMjIyCvjx07NmC97t27WxdccIHvtZ4Hut7ChQvzPEb2tvT7U/pX83pSUlLAep999plZ77333jOvhw0bFvBdhSLU802/j/Lly1ujR48OWK958+ZW165dfa8HDBhgValSxTp06FDAep07dzbrBuejZ555xsqvMWPGmP+bGz3Wffv2zbFczwH9P3v37jWvNa8mJibmWE+vQ7qenr9/RfNOv379zPefnp5ufffdd1b79u3N/jUfFuTao/v9z3/+E/DdNGnSxFxfbLqtpk2bmn36r6fLrr322oDttW3b9ox5S+lrPabBgs+R5557zqyr12x/V111lVW1alWTjvycC/r6r65fQLjRAgA44Prrrze15R988IGpmdRuD1rbE0y7ofz66685asm1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ghEjRjixeQAAAABuCgDmzZsnLVu2DFimr998800nNg8AAADATQGATkMUPP2QTkt04sQJJzYPAAAAwE0BQP369eXTTz8NWKav69Wr58TmAQAAALhpEPD9998vN954o4wePVoaN24sP/74ozz11FNmZiAAAAAARSwAuP322yUjI8PM/693Adaaf703wB133OHE5gEAAAC4KQBQgwYNMg8AAAAAHggA1G+//SapqakByxo0aODkLgAAAACEOwD4/PPP5eabb5Z9+/aJZVkSFRXl+5uVleXELgAAAAC4JQAYOnSo9OrVSwYPHixly5Z1YpMAAAAA3BoA7Nq1SzZu3CjFijkyqygAAACAQuJIib158+by008/ObEpAAAAAG5vAdB7APTu3VsefPBBqVGjRsB7nTp1cmIXAAAAANwSANx7773m76233hqwnEHAAAAAQBEMALKzs53YDAAAAIBCxqhdAAAAwEMcCQC0m8/EiRPlggsukLi4OLNs+fLlMmPGDCc2DwAAAMBNAUBSUpLMnz/f/NV+/6pRo0Yyffp0JzYPAAAAwE0BwJw5c2TRokXSr18/370A6tevL3v27HFi8wAAAADcFACkpqZKrVq1cnQLio52ZIwxAAAAADcFAPHx8bJgwYKAZQsXLpSEhAQnNg8AAADAIY5U0U+aNEk6d+4s77//vpw6dUoGDRpkAoIVK1Y4sXkAAAAAbmoBSExMlPXr10uVKlWkY8eO5r4AK1eulDZt2jixeQAAAAAOcayTfpMmTWTq1KlObQ4AAACAWwOAjz/+OM/3OnXq5MQuAAAAALglAND+/8Hs+wHobEAAAAAAitAYAO3z7//Yv3+/3HLLLfLuu+86sXkAAAAAbgoAgtWsWVOee+45eeihhwpj8wAAAADcFAAoy7Lkl19+KazNAwAAAAjXGICZM2cGvD5x4oS8+eabcvnllzuxeQAAAABuCgCSk5MDXsfGxkrr1q3liSeecGLzAAAAANwUAOzevduJzQAAAACI1DEAAAAAAIpoC8CVV17pm/e/oDcMAwAAABAhLQCXXHKJrF27VipVqiStWrWSypUry7p168zytm3b+h4AAAAAikALgE73OX/+fLnmmmt8y5YsWSKzZs2SZ5991oldAAAAAHBLC8CKFSukW7duAcu6du1qlgMAAAAoYgHAeeedJx9++GHAsuXLl0u1atWc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" width="768" style="display: block; margin: auto;" /></p>
<p>The results show that <code>Model 3</code> is selected most
frequently, indicating it offers the best predictive performance in the
majority of repetitions. <code>Model 4</code> is chosen only
occasionally, suggesting that adding <code>bill_length_mm</code> as a
predictor provides little to no improvement when
<code>flipper_length_mm</code> and <code>bill_depth_mm</code> are
already included in the model. This implies that
<code>bill_length_mm</code> may not contribute significant additional
predictive value.</p>
</div>
</div>
</div>
<script>
function showTab(id) {
  var contents = document.querySelectorAll('.tab-content');
  var buttons = document.querySelectorAll('.tab-button');

  contents.forEach(function(c) {
    c.classList.remove('active');
  });
  buttons.forEach(function(b) {
    b.classList.remove('active'); 
  });

  document.getElementById(id).classList.add('active');
  var btn = document.querySelector('button[onclick*="' + id + '"]');
  if (btn) btn.classList.add('active');
}
</script>
<script>
function toggleSolution(button) {
  var solution = button.nextElementSibling;
  if (solution.style.display === "none") {
    solution.style.display = "block";
  } else {
    solution.style.display = "none";
  }
}
</script>
</section>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
